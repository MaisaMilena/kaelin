/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./formality/stdlib/_export_to_webpack_.js":
/*!*************************************************!*\
  !*** ./formality/stdlib/_export_to_webpack_.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var array   = __webpack_require__(/*! ./array.fmc */ \"./formality/stdlib/array.fmc\").default;\nvar bits    = __webpack_require__(/*! ./bits.fmc */ \"./formality/stdlib/bits.fmc\").default;\nvar bool    = __webpack_require__(/*! ./bool.fmc */ \"./formality/stdlib/bool.fmc\").default;\nvar hash    = __webpack_require__(/*! ./hash.fmc */ \"./formality/stdlib/hash.fmc\").default;\nvar kaelin  = __webpack_require__(/*! ./kaelin.fmc */ \"./formality/stdlib/kaelin.fmc\").default;\nvar list    = __webpack_require__(/*! ./list.fmc */ \"./formality/stdlib/list.fmc\").default;\nvar main    = __webpack_require__(/*! ./main.fmc */ \"./formality/stdlib/main.fmc\").default;\nvar maybe   = __webpack_require__(/*! ./maybe.fmc */ \"./formality/stdlib/maybe.fmc\").default;\nvar nat     = __webpack_require__(/*! ./nat.fmc */ \"./formality/stdlib/nat.fmc\").default;\nvar num     = __webpack_require__(/*! ./num.fmc */ \"./formality/stdlib/num.fmc\").default;\nvar pair    = __webpack_require__(/*! ./pair.fmc */ \"./formality/stdlib/pair.fmc\").default;\nvar string  = __webpack_require__(/*! ./string.fmc */ \"./formality/stdlib/string.fmc\").default;\nvar term    = __webpack_require__(/*! ./term.fmc */ \"./formality/stdlib/term.fmc\").default;\nvar tree    = __webpack_require__(/*! ./tree.fmc */ \"./formality/stdlib/tree.fmc\").default;\nvar tuple   = __webpack_require__(/*! ./tuple.fmc */ \"./formality/stdlib/tuple.fmc\").default;\nvar vector2 = __webpack_require__(/*! ./vector2.fmc */ \"./formality/stdlib/vector2.fmc\").default;\n\nmodule.exports = [\n  array,\n  bits,\n  bool,\n  hash,\n  kaelin,\n  list,\n  main,\n  maybe,\n  nat,\n  num,\n  pair,\n  string,\n  term,\n  tree,\n  tuple,\n  vector2,\n].join(\"\\n\");\n\n\n\n//# sourceURL=webpack:///./formality/stdlib/_export_to_webpack_.js?");

/***/ }),

/***/ "./formality/stdlib/array.fmc":
/*!************************************!*\
  !*** ./formality/stdlib/array.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Efficient \\\"C-like\\\" arrays using perfect binary trees\\n\\n// Example usage of this library\\ndef array_example:\\n\\n  // Creates function to allocate an arrays of 65536 (2^16) elements\\n  let dpt  = ~16\\n  dup init = (init dpt)\\n\\n  // Allocates a new array and creates its methods\\n  # dup arr    = (init ##0)   // ~133k graph-rewrites to alloc 65536 zeros\\n    dup write  = (write dpt)  // ~650 graph-rewrites per write with dpt=16\\n    dup update = (update dpt) // ~650 graph-rewrites per update with dpt=16\\n    dup read   = (read dpt)   // ~650 graph-rewrites per read with dpt=16\\n\\n  // Performs some writes and reads\\n  # let add      = boxed_add\\n    let arr      = (write 0 #10 arr)       // arr[0] = 10\\n    let arr      = (write 1 #12 arr)       // arr[1] = 12\\n    let arr      = (update 2 (add #8) arr) // arr[2] += 8\\n    let arr      = (write 3 #7 arr)        // arr[1] = 12\\n    get [arr, a] = (read 0 arr)            // a = arr[0]\\n    get [arr, b] = (read 1 arr)            // b = arr[1]\\n    get [arr, c] = (read 2 arr)            // c = arr[2]\\n    get [arr, d] = (read 3 arr)            // c = arr[2]\\n    [\\\"arr[0] + arr[1] + arr[2]:\\\", (add (add a b) c)]\\n\\n// Example of folding over an array\\ndef fold_array_example:\\n  let array = [[[1,2],[3,4]],[[5,6],[7,8]]]\\n  let node  = {a b} |a + b|\\n  let leaf  = {x} |x * 2|\\n  dup fold  = (fold_array ~3)\\n  # (fold #array #node #leaf)\\n\\n// with\\n// | Searches an element, updates it, returns the updated\\n// | array and a value that can depend on the element\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {fn   : {x : A} (A,A)} -- Receives found element, returns an element to replace it by, and a return value.\\n//     {(Array dpt A)}        -- The array to be queried\\n//     ((Array dpt A), A)     -- The updated array, and return value returned by `fn`.\\ndef with: {dpt}\\n  let init = {path fn} fn\\n  let loop = {cont path fn}\\n    cpy path = path\\n    get [swap0,swap1] =\\n      if |path % 2|\\n      then: [{x}x, {x}x]\\n      else: [swap, swap]\\n    (cont |path / 2| {arr}\\n      get [a,b] = (swap0 arr)\\n      get [b,x] = (fn b)\\n      [(swap1 [a,b]), x])\\n  let stop = {func} func\\n  dup fold = (for dpt #init #loop #stop)\\n  # {path fn arr} (fold path fn arr)\\n\\n// update\\n// | Applies a function to an element\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {fn   : {x : A} A}     -- Update function\\n//     {arr  : (Array dpt A)} -- The array to be updated\\n//     (Array dpt A)          -- The updated array, and return value returned by `fn`.\\ndef update: {dpt}\\n  dup with = (with dpt) \\n  # {path f arr} (fst (with path {x}[(f x), 0] arr))\\n\\n// read\\n// | Returns a copy of an element and returns the array unchanged\\n// : {-A  : Type}              -- Type of the elements\\n//   {dpt : CNat}              -- Length of array = 2^dpt\\n//   ! {path : Num}            -- Num storing path to element\\n//     {arr  : (Array dpt !A)} -- The array to be read\\n//     {(Array dpt !A),!A}    -- The array itself, and a copy of the element\\ndef read: {dpt}\\n  dup with = (with dpt)\\n  # {path arr}\\n    let f = {x}\\n      dup x = x\\n      [#x, #x]\\n    (with path f arr)\\n\\n// peek\\n// | Like read, but on numeric, unboxed arrays\\n// : {-A  : Type}               -- Type of the elements\\n//   {dpt : CNat}               -- Length of array = 2^dpt\\n//   ! {path : Num}             -- Num storing path to element\\n//     {arr  : (Array dpt Num)} -- The array to be read\\n//     {(Array dpt Num), Num}   -- The array itself, and a copy of the element\\ndef peek: {dpt}\\n  dup with = (with dpt)\\n  # {path arr}\\n    let f = {x}\\n      cpy x = x\\n      [x, x]\\n    (with path f arr)\\n\\n// take\\n// | Takes an element out of an array and returns it\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {val  : A}             -- New value to put in place of old\\n//     {arr  : (Array dpt A)} -- The array to be taken\\n//     {(Array dpt A),A}      -- The updated array and the take element\\ndef take: {dpt}\\n  dup with = (with dpt)\\n  # {path val arr}\\n    (with path {x}[val,x] arr)\\n\\n// write\\n// | Overwrites an element of the array\\n// : {-A  : Type}             -- Type of hte elements\\n//   {dpt : CNat}             -- Length of the array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {arr  : (Array dpt A)} -- Array to be written\\n//     {val  : A}             -- Value to be written\\n//     (Array dpt A)          -- The overwritten array\\ndef write: {dpt}\\n  dup update = (update dpt)\\n  # {path val} (update path {x}val)\\n\\n// init\\n// | Generates an array with 2^dpt copies of val\\n// : {-A  : Type}\\n//   {dpt : CNat}\\n//   ! {val : !A}\\n//   ! (Array dpt A)\\ndef init: {dpt}\\n  let loop = {arr}\\n    dup arr = arr\\n    # [arr, arr]\\n  dup fold = (dpt #loop)\\n  # {init} (fold init)\\n\\n// gen\\n// | Generates an array by mapping a function to each index\\n// : {-A  : Type}\\n//   {dpt : CNat}\\n//   ! {fun : !{idx : !Num} A}\\n//   ! (Array dpt !A)\\ndef gen: {dpt}\\n  let init = {fun}\\n    dup fun = fun\\n    # {idx} (fun idx)\\n  let loop = {arr fun}\\n    dup arr = (arr fun)\\n    # {idx}\\n      dup idx = idx\\n      let lft = (arr #||idx * 2| + 0|)\\n      let rgt = (arr #||idx * 2| + 1|)\\n      [lft, rgt]\\n  let stop = {arr fun}\\n    dup arr = (arr fun)\\n    # (arr #0)\\n  (for dpt #init #loop #stop)\\n\\n// range\\n// | Generates an array with all numbers from 0 to 2^dpt\\n// : {dpt : CNat}\\n//   !!(Array dpt !Num)\\ndef range: {dpt}\\n  dup gen = (gen dpt)\\n  # (gen #{x}x)\\n\\n// fold_array\\n// : {-A : Type}\\n//   {dpt : Nat}\\n//   ! {-P   : Type}\\n//     {Node : !{lft : A} {rgt : A} P}\\n//     {Leaf : !{val : A} P}\\n//     ! {arr  : !(Array dpt A)}\\n//       P\\ndef fold_array: {dpt}\\n  let init = {Node Leaf}\\n    dup Node = Node\\n    dup Leaf = Leaf\\n    # {val} (Leaf val)\\n  let loop = {rec Node Leaf}\\n    dup Node = Node\\n    dup Leaf = Leaf\\n    dup rec  = (rec #Node #Leaf)\\n    # {arr}\\n      get [lft,rgt] = arr\\n      let lft = (rec lft)\\n      let rgt = (rec rgt)\\n      (Node lft rgt)\\n  dup fold = (dpt #loop)\\n  # (fold init)\\n\\n// fold_array_of_len\\n// | Like `fold_array`, but needs length and can operate on arrays at level 1\\n// | Requires much more rewrites to build, but is equally efficient once built\\n// : {-A   : Type}\\n//   {mlen : Nat}\\n//   {mdpt : Num}\\n//   {-P   : Type}\\n//   {Node : !{lft : A} {rgt : A} P}\\n//   {Leaf : !{val : A} P}\\n//   ! {arr  : !(Array dpt A)}\\n//     P\\ndef fold_array_of_len: {mlen mdpt Node Leaf}\\n  dup mdpt = mdpt\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  dup fold = (mul ~2 mlen # {rec dpt arr}\\n    cpy dpt = dpt\\n    (if |dpt < mdpt|\\n      then: {rec arr}\\n        get [lft,rgt] = arr\\n        get [rec,lft] = (rec |dpt + 1| lft)\\n        get [rec,rgt] = (rec |dpt + 1| rgt)\\n        [rec, (Node lft rgt)]\\n      else: {rec arr}\\n        [rec, (Leaf arr)]\\n      rec arr))\\n  # {arr} (snd (fold {dpt arr}[{x}x,arr] 0 arr))\\n\\n// array_1024\\n// : (Array ~10 Num)\\ndef array_1024:\\n  let a = [1,1]\\n  let b = [a,a]\\n  let c = [b,b]\\n  let d = [c,c]\\n  let e = [d,d]\\n  let f = [e,e]\\n  let g = [f,f]\\n  let h = [g,g]\\n  let i = [h,h]\\n  [i,i]\\n\\ndef fold_array_lv1_example:\\n  dup fold = (fold_array_lv1 ~1024 #10 #{a b}|a + b| #{x}x)\\n  # |(fold array_1024) + (fold array_1024)|\\n\\ndef fold_array_example:\\n  dup fold = (fold_array ~10)\\n  # dup fold = (fold #{a b}|a + b| #{x}x)\\n  # (fold array_1024)\\n\\ndef array:\\n  fold_array_example\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/array.fmc?");

/***/ }),

/***/ "./formality/stdlib/bits.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/bits.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def o: {bs o i e} (o bs)\\ndef i: {bs o i e} (i bs)\\ndef e:    {o i e} e\\n\\ndef inc_cont: {bs cont}\\n  {o i e}\\n  let case_o = i\\n  let case_i = {x} (o (cont x))\\n  let case_e = e\\n  (bs case_o case_i case_e) \\n\\ndef inc: {n}\\n  let case_s = # {cont bs} (inc_cont bs cont)\\n  let case_z = {bs} bs\\n  dup S = (n case_s)\\n  # (S case_z)\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/bits.fmc?");

/***/ }),

/***/ "./formality/stdlib/bool.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/bool.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// ::::::::::\\n// :: Bool ::\\n// ::::::::::\\n\\ndef true:\\n  {t f} t\\n\\ndef false:\\n  {t f} f\\n\\ndef not: {b}\\n  {t f} (b f t)\\n\\ndef eql: {a b}\\n  (a {x}x not b)\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/bool.fmc?");

/***/ }),

/***/ "./formality/stdlib/hash.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/hash.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def keccak.f_loop: {arr} {t}\\n  (arr {n\\n    a00 a01 a02 a03 a04 a05 a06 a07 a08 a09\\n    a10 a11 a12 a13 a14 a15 a16 a17 a18 a19\\n    a20 a21 a22 a23 a24 a25 a26 a27 a28 a29\\n    a30 a31 a32 a33 a34 a35 a36 a37 a38 a39\\n    a40 a41 a42 a43 a44 a45 a46 a47 a48 a49}\\n\\n    dup n   = n\\n    dup a00 = a00\\n    dup a01 = a01\\n    dup a02 = a02\\n    dup a03 = a03\\n    dup a04 = a04\\n    dup a05 = a05\\n    dup a06 = a06\\n    dup a07 = a07\\n    dup a08 = a08\\n    dup a09 = a09\\n    dup a10 = a10\\n    dup a11 = a11\\n    dup a12 = a12\\n    dup a13 = a13\\n    dup a14 = a14\\n    dup a15 = a15\\n    dup a16 = a16\\n    dup a17 = a17\\n    dup a18 = a18\\n    dup a19 = a19\\n    dup a20 = a20\\n    dup a21 = a21\\n    dup a22 = a22\\n    dup a23 = a23\\n    dup a24 = a24\\n    dup a25 = a25\\n    dup a26 = a26\\n    dup a27 = a27\\n    dup a28 = a28\\n    dup a29 = a29\\n    dup a30 = a30\\n    dup a31 = a31\\n    dup a32 = a32\\n    dup a33 = a33\\n    dup a34 = a34\\n    dup a35 = a35\\n    dup a36 = a36\\n    dup a37 = a37\\n    dup a38 = a38\\n    dup a39 = a39\\n    dup a40 = a40\\n    dup a41 = a41\\n    dup a42 = a42\\n    dup a43 = a43\\n    dup a44 = a44\\n    dup a45 = a45\\n    dup a46 = a46\\n    dup a47 = a47\\n    dup a48 = a48\\n    dup a49 = a49\\n\\n    dup c0 = #||||a00 ^ a10| ^ a20| ^ a30| ^ a40|\\n    dup c1 = #||||a01 ^ a11| ^ a21| ^ a31| ^ a41|\\n    dup c2 = #||||a02 ^ a12| ^ a22| ^ a32| ^ a42|\\n    dup c3 = #||||a03 ^ a13| ^ a23| ^ a33| ^ a43|\\n    dup c4 = #||||a04 ^ a14| ^ a24| ^ a34| ^ a44|\\n    dup c5 = #||||a05 ^ a15| ^ a25| ^ a35| ^ a45|\\n    dup c6 = #||||a06 ^ a16| ^ a26| ^ a36| ^ a46|\\n    dup c7 = #||||a07 ^ a17| ^ a27| ^ a37| ^ a47|\\n    dup c8 = #||||a08 ^ a18| ^ a28| ^ a38| ^ a48|\\n    dup c9 = #||||a09 ^ a19| ^ a29| ^ a39| ^ a49|\\n\\n    dup h   = #|c8 ^ ||c2 << 1| | |c3 >> 31|||\\n    dup l   = #|c9 ^ ||c3 << 1| | |c2 >> 31|||\\n    dup a00 = #|a00 ^ h|\\n    dup a01 = #|a01 ^ l|\\n    dup a10 = #|a10 ^ h|\\n    dup a11 = #|a11 ^ l|\\n    dup a20 = #|a20 ^ h|\\n    dup a21 = #|a21 ^ l|\\n    dup a30 = #|a30 ^ h|\\n    dup a31 = #|a31 ^ l|\\n    dup a40 = #|a40 ^ h|\\n    dup a41 = #|a41 ^ l|\\n\\n    dup h   = #|c0 ^ ||c4 << 1| | |c5 >> 31|||\\n    dup l   = #|c1 ^ ||c5 << 1| | |c4 >> 31|||\\n    dup a02 = #|a02 ^ h|\\n    dup a03 = #|a03 ^ l|\\n    dup a12 = #|a12 ^ h|\\n    dup a13 = #|a13 ^ l|\\n    dup a22 = #|a22 ^ h|\\n    dup a23 = #|a23 ^ l|\\n    dup a32 = #|a32 ^ h|\\n    dup a33 = #|a33 ^ l|\\n    dup a42 = #|a42 ^ h|\\n    dup a43 = #|a43 ^ l|\\n\\n    dup h   = #|c2 ^ ||c6 << 1| | |c7 >> 31|||\\n    dup l   = #|c3 ^ ||c7 << 1| | |c6 >> 31|||\\n    dup a04 = #|a04 ^ h|\\n    dup a05 = #|a05 ^ l|\\n    dup a14 = #|a14 ^ h|\\n    dup a15 = #|a15 ^ l|\\n    dup a24 = #|a24 ^ h|\\n    dup a25 = #|a25 ^ l|\\n    dup a34 = #|a34 ^ h|\\n    dup a35 = #|a35 ^ l|\\n    dup a44 = #|a44 ^ h|\\n    dup a45 = #|a45 ^ l|\\n\\n    dup h   = #|c4 ^ ||c8 << 1| | |c9 >> 31|||\\n    dup l   = #|c5 ^ ||c9 << 1| | |c8 >> 31|||\\n    dup a06 = #|a06 ^ h|\\n    dup a07 = #|a07 ^ l|\\n    dup a16 = #|a16 ^ h|\\n    dup a17 = #|a17 ^ l|\\n    dup a26 = #|a26 ^ h|\\n    dup a27 = #|a27 ^ l|\\n    dup a36 = #|a36 ^ h|\\n    dup a37 = #|a37 ^ l|\\n    dup a46 = #|a46 ^ h|\\n    dup a47 = #|a47 ^ l|\\n\\n    dup h   = #|c6 ^ ||c0 << 1| | |c1 >> 31|||\\n    dup l   = #|c7 ^ ||c1 << 1| | |c0 >> 31|||\\n    dup a08 = #|a08 ^ h|\\n    dup a09 = #|a09 ^ l|\\n    dup a18 = #|a18 ^ h|\\n    dup a19 = #|a19 ^ l|\\n    dup a28 = #|a28 ^ h|\\n    dup a29 = #|a29 ^ l|\\n    dup a38 = #|a38 ^ h|\\n    dup a39 = #|a39 ^ l|\\n    dup a48 = #|a48 ^ h|\\n    dup a49 = #|a49 ^ l|\\n\\n    dup b00 = #a00\\n    dup b01 = #a01\\n    dup b32 = #||a11 <<  4| | |a10 >> 28||\\n    dup b33 = #||a10 <<  4| | |a11 >> 28||\\n    dup b14 = #||a20 <<  3| | |a21 >> 29||\\n    dup b15 = #||a21 <<  3| | |a20 >> 29||\\n    dup b46 = #||a31 <<  9| | |a30 >> 23||\\n    dup b47 = #||a30 <<  9| | |a31 >> 23||\\n    dup b28 = #||a40 << 18| | |a41 >> 14||\\n    dup b29 = #||a41 << 18| | |a40 >> 14||\\n    dup b20 = #||a02 <<  1| | |a03 >> 31||\\n    dup b21 = #||a03 <<  1| | |a02 >> 31||\\n    dup b02 = #||a13 << 12| | |a12 >> 20||\\n    dup b03 = #||a12 << 12| | |a13 >> 20||\\n    dup b34 = #||a22 << 10| | |a23 >> 22||\\n    dup b35 = #||a23 << 10| | |a22 >> 22||\\n    dup b16 = #||a33 << 13| | |a32 >> 19||\\n    dup b17 = #||a32 << 13| | |a33 >> 19||\\n    dup b48 = #||a42 << 02| | |a43 >> 30||\\n    dup b49 = #||a43 << 02| | |a42 >> 30||\\n    dup b40 = #||a05 << 30| | |a04 >>  2||\\n    dup b41 = #||a04 << 30| | |a05 >>  2||\\n    dup b22 = #||a14 << 06| | |a15 >> 26||\\n    dup b23 = #||a15 << 06| | |a14 >> 26||\\n    dup b04 = #||a25 << 11| | |a24 >> 21||\\n    dup b05 = #||a24 << 11| | |a25 >> 21||\\n    dup b36 = #||a34 << 15| | |a35 >> 17||\\n    dup b37 = #||a35 << 15| | |a34 >> 17||\\n    dup b18 = #||a45 << 29| | |a44 >>  3||\\n    dup b19 = #||a44 << 29| | |a45 >>  3||\\n    dup b10 = #||a06 << 28| | |a07 >>  4||\\n    dup b11 = #||a07 << 28| | |a06 >>  4||\\n    dup b42 = #||a17 << 23| | |a16 >>  9||\\n    dup b43 = #||a16 << 23| | |a17 >>  9||\\n    dup b24 = #||a26 << 25| | |a27 >>  7||\\n    dup b25 = #||a27 << 25| | |a26 >>  7||\\n    dup b06 = #||a36 << 21| | |a37 >> 11||\\n    dup b07 = #||a37 << 21| | |a36 >> 11||\\n    dup b38 = #||a47 << 24| | |a46 >>  8||\\n    dup b39 = #||a46 << 24| | |a47 >>  8||\\n    dup b30 = #||a08 << 27| | |a09 >>  5||\\n    dup b31 = #||a09 << 27| | |a08 >>  5||\\n    dup b12 = #||a18 << 20| | |a19 >> 12||\\n    dup b13 = #||a19 << 20| | |a18 >> 12||\\n    dup b44 = #||a29 << 07| | |a28 >> 25||\\n    dup b45 = #||a28 << 07| | |a29 >> 25||\\n    dup b26 = #||a38 << 08| | |a39 >> 24||\\n    dup b27 = #||a39 << 08| | |a38 >> 24||\\n    dup b08 = #||a48 << 14| | |a49 >> 18||\\n    dup b09 = #||a49 << 14| | |a48 >> 18||\\n\\n    dup a00 = #|b00 ^ ||0 ~ b02| & b04||\\n    dup a01 = #|b01 ^ ||0 ~ b03| & b05||\\n    dup a10 = #|b10 ^ ||0 ~ b12| & b14||\\n    dup a11 = #|b11 ^ ||0 ~ b13| & b15||\\n    dup a20 = #|b20 ^ ||0 ~ b22| & b24||\\n    dup a21 = #|b21 ^ ||0 ~ b23| & b25||\\n    dup a30 = #|b30 ^ ||0 ~ b32| & b34||\\n    dup a31 = #|b31 ^ ||0 ~ b33| & b35||\\n    dup a40 = #|b40 ^ ||0 ~ b42| & b44||\\n    dup a41 = #|b41 ^ ||0 ~ b43| & b45||\\n    dup a02 = #|b02 ^ ||0 ~ b04| & b06||\\n    dup a03 = #|b03 ^ ||0 ~ b05| & b07||\\n    dup a12 = #|b12 ^ ||0 ~ b14| & b16||\\n    dup a13 = #|b13 ^ ||0 ~ b15| & b17||\\n    dup a22 = #|b22 ^ ||0 ~ b24| & b26||\\n    dup a23 = #|b23 ^ ||0 ~ b25| & b27||\\n    dup a32 = #|b32 ^ ||0 ~ b34| & b36||\\n    dup a33 = #|b33 ^ ||0 ~ b35| & b37||\\n    dup a42 = #|b42 ^ ||0 ~ b44| & b46||\\n    dup a43 = #|b43 ^ ||0 ~ b45| & b47||\\n    dup a04 = #|b04 ^ ||0 ~ b06| & b08||\\n    dup a05 = #|b05 ^ ||0 ~ b07| & b09||\\n    dup a14 = #|b14 ^ ||0 ~ b16| & b18||\\n    dup a15 = #|b15 ^ ||0 ~ b17| & b19||\\n    dup a24 = #|b24 ^ ||0 ~ b26| & b28||\\n    dup a25 = #|b25 ^ ||0 ~ b27| & b29||\\n    dup a34 = #|b34 ^ ||0 ~ b36| & b38||\\n    dup a35 = #|b35 ^ ||0 ~ b37| & b39||\\n    dup a44 = #|b44 ^ ||0 ~ b46| & b48||\\n    dup a45 = #|b45 ^ ||0 ~ b47| & b49||\\n    dup a06 = #|b06 ^ ||0 ~ b08| & b00||\\n    dup a07 = #|b07 ^ ||0 ~ b09| & b01||\\n    dup a16 = #|b16 ^ ||0 ~ b18| & b10||\\n    dup a17 = #|b17 ^ ||0 ~ b19| & b11||\\n    dup a26 = #|b26 ^ ||0 ~ b28| & b20||\\n    dup a27 = #|b27 ^ ||0 ~ b29| & b21||\\n    dup a36 = #|b36 ^ ||0 ~ b38| & b30||\\n    dup a37 = #|b37 ^ ||0 ~ b39| & b31||\\n    dup a46 = #|b46 ^ ||0 ~ b48| & b40||\\n    dup a47 = #|b47 ^ ||0 ~ b49| & b41||\\n    dup a08 = #|b08 ^ ||0 ~ b00| & b02||\\n    dup a09 = #|b09 ^ ||0 ~ b01| & b03||\\n    dup a18 = #|b18 ^ ||0 ~ b10| & b12||\\n    dup a19 = #|b19 ^ ||0 ~ b11| & b13||\\n    dup a28 = #|b28 ^ ||0 ~ b20| & b22||\\n    dup a29 = #|b29 ^ ||0 ~ b21| & b23||\\n    dup a38 = #|b38 ^ ||0 ~ b30| & b32||\\n    dup a39 = #|b39 ^ ||0 ~ b31| & b33||\\n    dup a48 = #|b48 ^ ||0 ~ b40| & b42||\\n    dup a49 = #|b49 ^ ||0 ~ b41| & b43||\\n\\n    dup rcs = # \\n      if |n < 12|\\n      then: if |n < 6|\\n      then: if |n < 3|\\n      then: if |n < 2|\\n      then: if |n < 1|\\n      then: [1,0]\\n      else: [32898,0]\\n      else: [32906,2147483648]\\n      else: if |n < 5|\\n      then: if |n < 4|\\n      then: [2147516416,2147483648]\\n      else: [32907,0]\\n      else: [2147483649,0]\\n      else: if |n < 9|\\n      then: if |n < 8|\\n      then: if |n < 7|\\n      then: [2147516545,2147483648]\\n      else: [32777,2147483648]\\n      else: [138,0]\\n      else: if |n < 11|\\n      then: if |n < 10|\\n      then: [136,0]\\n      else: [2147516425,0]\\n      else: [2147483658,0]\\n      else: if |n < 18|\\n      then: if |n < 15|\\n      then: if |n < 14|\\n      then: if |n < 13|\\n      then: [2147516555,0]\\n      else: [139,2147483648]\\n      else: [32905,2147483648]\\n      else: if |n < 17|\\n      then: if |n < 16|\\n      then: [32771,2147483648]\\n      else: [32770,2147483648]\\n      else: [128,2147483648]\\n      else: if |n < 21|\\n      then: if |n < 20|\\n      then: if |n < 19|\\n      then: [32778,0]\\n      else: [2147483658,2147483648]\\n      else: [2147516545,2147483648]\\n      else: if |n < 23|\\n      then: if |n < 22|\\n      then: [32896,2147483648]\\n      else: [2147483649,0]\\n      else: [2147516424,2147483648]\\n\\n    dup a00 = #|fst rcs ^ a00|\\n    dup a01 = #|snd rcs ^ a01|\\n\\n    (t\\n      #|n + 1|\\n      #a00 #a01 #a02 #a03 #a04 #a05 #a06 #a07 #a08 #a09\\n      #a10 #a11 #a12 #a13 #a14 #a15 #a16 #a17 #a18 #a19\\n      #a20 #a21 #a22 #a23 #a24 #a25 #a26 #a27 #a28 #a29\\n      #a30 #a31 #a32 #a33 #a34 #a35 #a36 #a37 #a38 #a39\\n      #a40 #a41 #a42 #a43 #a44 #a45 #a46 #a47 #a48 #a49))\\n\\ndef keccak.f: {arr}\\n  dup arr = arr\\n  // transform array of 200 bytes into an array of 50 words\\n  dup arr =\\n    let 2num = {b1 b2 b3 b4} |b1 + ||b2 + ||b3 + |b4 << 8|| << 8|| << 8||\\n    let loop = {arr} {cont t} (arr {k} {b1 b2 b3 b4} (cont (k (2num b1 b2 b3 b4))) t)\\n    dup f = (for ~50 #{cont t} (cont t) #loop #{k} (k {x} x))\\n    #{t} (arr (f t))\\n  dup arr = (for ~24 #(pushfront 0 arr) #keccak.f_loop #popfront)\\n  // transform array of 50 words into an array of 50 tuples of 4 bytes\\n  dup arr =\\n    let 2bytes = {x} {t}\\n      cpy x = x\\n      let b1 = |x % 256|\\n      let x = |x >> 8|\\n      cpy x = x\\n      let b2 = |x % 256|\\n      let x = |x >> 8|\\n      cpy x = x\\n      let b3 = |x % 256|\\n      let b4 = |x >> 8|\\n      (t b1 b2 b3 b4)\\n    let init = {cont t} (cont t)\\n    let loop = {arr} {cont t} (arr {k} {num} (cont (k (2bytes num))) t)\\n    let stop = {k} (k {x} x)\\n    dup f = (for ~50 #init #loop #stop)\\n    #{t} (arr (f t))\\n  // transform array of 50 tuples of 4 bytes into an array of 200 bytes\\n  dup arr =\\n    let init = {cont} (cont {t} t)\\n    let loop = {fun} {cont} (fun {k} {tup} (cont {t} (tup (k t))))\\n    let stop = {k} (k {x} x)\\n    dup f = (for ~50 #init #loop #stop)\\n    #(arr f)\\n  #arr\\n\\ndef update_zero: {t k} (k t)\\ndef pushfront_update: {f update} {t k} {x} (update (t (f x)) k)\\ndef pushback_update: {f update} {t k} (update t {tup} {x} (k (tup (f x))))\\ndef apply_update: {update arr} {t} (arr (update t {x} x))\\n\\ndef Keccak256: {bytes}\\n  let state = (for ~200 #{t} t #(pushfront #0) #{x} x)\\n  let update = update_zero\\n  let fold_cons = {x h i state update F}\\n    cpy i = i\\n    (if ||i % 136| == 135|\\n    then: {x h i state update F}\\n      dup x = x\\n      dup state = state\\n      dup update = update\\n      dup F = F\\n      (h |i + 1| #(F (apply_update (pushback_update {y} |x ^ y| update) state)) #update_zero #F)\\n    else: {x h i state update F}\\n      dup x = x\\n      dup update = update\\n      (h |i + 1| state #(pushback_update {y} |x ^ y| update) F)\\n    x h i state update F)\\n  let fold_nil = {i state update F}\\n    dup state = state\\n    dup update = update\\n    dup F = F\\n    dup state = #(apply_update (pushback_update {y} |y ^ 1| update) state)\\n    // xor the position 135 of the state with 0x80\\n    dup state =\\n      dup f = (for ~135 #{t x} (t |x ^ 128|) #{fun t x} (fun (t x)) #{x} x)\\n      #{t} (state (f t))\\n    dup state = #(F state)\\n    #(state {a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 a24 a25 a26 a27 a28 a29 a30 a31 a32 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -}\\n      (ConsF a1 (ConsF a2 (ConsF a3 (ConsF a4 (ConsF a5 (ConsF a6 (ConsF a7 (ConsF a8 (ConsF a9 (ConsF a10 (ConsF a11 (ConsF a12 (ConsF a13 (ConsF a14 (ConsF a15 (ConsF a16 (ConsF a17 (ConsF a18 (ConsF a19 (ConsF a20 (ConsF a21 (ConsF a22 (ConsF a23 (ConsF a24 (ConsF a25 (ConsF a26 (ConsF a27 (ConsF a28 (ConsF a29 (ConsF a30 (ConsF a31 (ConsF a32 NilF)))))))))))))))))))))))))))))))))\\n  dup fold = (bytes #fold_cons)\\n# (fold fold_nil 0 state #update #keccak.f)\\n\\ndef bytes_to_hex: {xs}\\n  (from_chars\\n  {Cons}\\n  dup Cons = Cons\\n  dup fold =\\n    (xs #{x h}\\n      cpy x = x\\n      let a0 = (num_to_char |x % 16|)\\n      let a1 = (num_to_char |x / 16|)\\n      (Cons a1 (Cons a0 h)))\\n  #{n} (fold n))\\n\\ndef stringtest: \\\"random hash\\\"\\ndef keccaktest: (bytes_to_hex (Keccak256 (to_chars stringtest)))\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/hash.fmc?");

/***/ }),

/***/ "./formality/stdlib/kaelin.fmc":
/*!*************************************!*\
  !*** ./formality/stdlib/kaelin.fmc ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// ## Kaelin\\n// \\n// A simple, blockhain-enabled MOBA implemented in Formality-Core.\\n// \\n// Kaelin aims to capture some of the spirit of a MOBA, inluding map awareness,\\n// micro and macro strategies, resource control, team-fights, skillshots and so\\n// on, while aiming blockchain-compatible by being very lightweight (the entire\\n// game state has only 8192 bits) and based on ~20 second turns. This allows it\\n// to run on state-channels and use Ethereum for conflict resolution.\\n// \\n// ## Heroes\\n// \\n// Name    | Role   | Description    | MOV | HP  | References & Inspiration\\n// ------- | ------ | -------------- | --- | --- | -------------------------------------------------\\n// Tophoro | Tank   | Terrain Bender |   3 |  60 | Toph (Avatar TLA), Totoro (Studio Ghibli)\\n// Gonk    | Tank   | Warrior        |   3 |  40 | Gon (Hunter X Hunter), Goku (Gradon Ball Z)\\n// Stanci  | Tank   | Healer         |   3 |  40 | Dev\\n// ?????   | Tank   |                |     |     | \\n// Erkos   | Ranged | Fire Mage      |   3 |  20 | Erk (Fire Emblem), Harry Potter (Harry Potter)\\n// Croni   | Ranged | Dark Mage      |   3 |  20 | Chromie (Blizzard), Raven (Teen Titans)\\n// Snarch  | Ranged | Archer         |   3 |  20 | Zk-Snarks (crypto)\\n// ?????   | Ranged | ?              |     |     |\\n// Sirpix  | Melee  | Thief          |   3 |  30 | Dev\\n// Kenlua  | Melee  | Swordsman      |   3 |  30 | Killua (Hunter X Hunter), Kenshin (Rurouni Kenshin)\\n// Flina   | Melee  | Pegasus Knight |   3 |  30 | Florina (Fire Emblem), Link (The Legend of Zelda)\\n// ?????   | Melee  | ?              |   3 |  30 | ????\\n// Zagatur | Tactic | Summoner       |   0 |   4 | Zagara, Abathur (Blizzard)\\n// Agdris  | Tactic | Silencer       |   2 |  10 | Agda, Idris (programming language)\\n// Mewem   | Tactic | Psychic        |   0 |  10 | Mewtwo (Pokémon), Meruem (Hunter X Hunter)\\n// ?????   | Tactic | ?              |   ? |  ?? | ????\\n//\\n// ## Moves\\n// \\n// HERO    | MOVE           | EFFECT\\n// ------- | -------------- | ------\\n// TOPHORO | Earth_Root     | Heals 20 hp. Self-roots for 3 turns. Fast.\\n// TOPHORO | Earth_Wall     | Range: 2. Area: 1. Places a temporary wall. Fast.\\n// TOPHORO | Earth_Rise     | Range: 2. Area: 1. Damage: 2. Mutes.\\n// GONK    | Empathy        | Range: 1. Area: 1. Armor: 5. Fast. Loses 2 HP.\\n// GONK    | Revenge        | Range: 1. Area: 0. Fast. Damage: `missing_hp / 4`. Fast.\\n// GONK    | Ground_Slam    | Range: 0. Area: 2. Damage: 2. Mutes.\\n// STANCI  | Restore        | Range: 3. Area: 0. Heal: 3. Fast.\\n// STANCI  | Escort         | Range: 3. Area: 0. Armor: 3. Fast.\\n// STANCI  | Detain         | Range: 3. Area: 0. Mutes. Fast.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// ERKOS   | Flame_Ball     | Range: 3. Area: 2. Damage: 3.\\n// ERKOS   | Flame_Wave     | Range: 3. Area: 1. Damage: 5.\\n// ERKOS   | Flame_Nova     | Range: 0. Area: 6. Damage: 15. Loses 30 HP.\\n// CRONI   | Shadow_Bond    | Fast. Loses 3 HP. If enemy at given position kills Croni this turn, it dies too.\\n// CRONI   | Shadow_Trap    | Range: 6. Area: 0. Fast. Places a trap that locks whoever steps on it.\\n// CRONI   | Shadow_Flux    | Range: 6. Area: 1. Damage: 8.\\n// SNARCH  | Ballista       | Mounts from a ballista, doubling Snarch's range and locking him. Can't attack on this turn.\\n// SNARCH  | Quick_Bolt_0   | Range: 5. Area: 0. Damage: 2. Fast.\\n// SNARCH  | Quick_Bolt_1   | Range: 5. Area: 0. Damage: 2. Fast.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// SIRPIX  | Stealth_Move   | Moves your Stealth Clone up to 3 range.\\n// SIRPIX  | Stealth_Strike | Range: 0. Area: 0. Damage: 3. Before attacking, swaps position with your Stealth Clone.\\n// SIRPIX  | Lockpick       | Special effects on map.\\n// KENLUA  | Haste          | Range: 3. Area: 0. Loses 2 hp. Blinks to target. Range: 0. Area: 1. Damage: 4.\\n// KENLUA  | Dodge          | Range: 32. Can't take damage from target during this turn.\\n// KENLUA  | Slash          | Range: 1. Area: 0. Damage: 12.\\n// FLINA   | Javelin        | Range: 2. Area: 0. Damage: 4. Fast.\\n// FLINA   | Fly            | Range: 3. Area: 0. Blinks to target.\\n// FLINA   | Gust           | Range: 2. Area: 1. Damage: 3.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// ZAGATUR | Wrap           | Range: 0. Area: 1. Fast. Locks.\\n// ZAGATUR | Needle         | Range: 0. Area: 1. Damage: 3.\\n// ZAGATUR | Summon         | Range: 3. Spawns a clone of Zagatur.\\n// AGDRIS  | Memento        | Range: 32. Area: 2. Damage: 2. Fast. Heal: 2. Armor: 2. Locks. Mutes. Dies.\\n// AGDRIS  | Silence        | Range: 32. Area: 0. Mutes.\\n// AGDRIS  | Protect        | Range: 32. Area: 0. Armor: 3.\\n// MEWRU   | Teleport       | Range: 32. Fast. Blinks to target.\\n// MEWRU   | Psychock       | hits a 3x3 area up to 4 range, dealing 6 damage.\\n// MEWRU   | Imprison       | hits a 3x3 area up to 4 range, locking enemies.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// \\n// Hero    | Skill F           | Skill D             | Skill S\\n// ------- | ----------------- | ------------------- | -----------------\\n// TOPHORO | Earth_Root        | Earth_Wall          | Earth_Rise     \\n// GONK    | Empathy           | Revenge             | Ground_Slam     \\n// STANCI  | Restore           | Escort              | Detain     \\n// ERKOS   | Flame_Ball        | Flame_Wave          | Flame_Nova     \\n// CRONI   | Shadow_Bond       | Shadow_Trap         | Shadow_Flux     \\n// SNARCH  | Ballista          | Quick_Bolt_0        | Quick_Bolt_1\\n// SIRPIX  | Stealth_Move      | Stealth_Strike      | Lockpick     \\n// KENLUA  | Haste             | Dodge               | Slash     \\n// FLINA   | Javelin           | Fly                 | Gust\\n// ZAGATUR | Wrap              | Needle              | Summon     \\n// AGDRIS  | Memento           | Silence             | Protect     \\n// MEWRU   | Teleport          | Psychock            | Imprison     \\n\\ndef kaelin:\\n\\n  // :::::::::::\\n  // :: Array ::\\n  // :::::::::::\\n\\n  dup fold4    = (fold_array ~4)\\n  dup fold6    = (fold_array ~6)\\n  dup fold8    = (fold_array ~8) \\n  dup init4    = (init ~4)\\n  dup init6    = (init ~6)\\n  dup init8    = (init ~8) #\\n  dup with4    = (with ~4)\\n  dup take4    = (take ~4)\\n  dup update4  = (update ~4)\\n  dup write4   = (write ~4)\\n  dup with6    = (with ~6)\\n  dup take6    = (take ~6)\\n  dup update6  = (update ~6)\\n  dup write6   = (write ~6)\\n  dup with8    = (with ~8)\\n  dup take8    = (take ~8)\\n  dup update8  = (update ~8)\\n  dup write8   = (write ~8)\\n\\n  // :::::::::::::::\\n  // :: Direction ::\\n  // :::::::::::::::\\n\\n  dup RIGHT = #[ 1, 0]\\n  dup DOWN  = #[ 0, 1]\\n  dup LEFT  = #[-1, 0]\\n  dup UP    = #[ 0,-1]\\n\\n  // ::::::::::\\n  // :: Side ::\\n  // ::::::::::\\n\\n  dup WHITE = # 0\\n  dup BLACK = # 1\\n  dup BOARD = # 2\\n\\n  dup is_enemy_side = # {a b}\\n    cpy a = a\\n    cpy b = b\\n    |||a == WHITE| & |b == BLACK|| | ||a == BLACK| & |b == WHITE|||\\n    \\n  dup is_ally_side = # {a b}\\n    cpy a = a\\n    cpy b = b\\n    |||a == WHITE| & |b == WHITE|| | ||a == BLACK| & |b == BLACK|||\\n\\n  // ::::::::::\\n  // :: Hero ::\\n  // ::::::::::\\n\\n  dup TOPHORO  = # 0\\n  dup GONK     = # 1\\n  dup STANCI   = # 2\\n  dup HERO_3   = # 3\\n  dup ERKOS    = # 4\\n  dup CRONI    = # 5\\n  dup SNARCH   = # 6\\n  dup HERO_7   = # 7\\n  dup SIRPIX   = # 8\\n  dup KENLUA   = # 9\\n  dup FLINA    = # 10\\n  dup HERO_B   = # 11\\n  dup ZAGATUR  = # 12\\n  dup AGDRIS   = # 13\\n  dup MEWEM    = # 14\\n  dup HERO_F   = # 15\\n\\n  // Given a hero, returns its icon\\n  dup get_hero_icon = # {hero}\\n    let hero00 = (to_chars \\\"To\\\")\\n    let hero01 = (to_chars \\\"Go\\\")\\n    let hero02 = (to_chars \\\"St\\\")\\n    let hero03 = (to_chars \\\"??\\\")\\n    let hero04 = (to_chars \\\"Er\\\")\\n    let hero05 = (to_chars \\\"Cr\\\")\\n    let hero06 = (to_chars \\\"Sn\\\")\\n    let hero07 = (to_chars \\\"??\\\")\\n    let hero08 = (to_chars \\\"Si\\\")\\n    let hero09 = (to_chars \\\"Ke\\\")\\n    let hero10 = (to_chars \\\"Fl\\\")\\n    let hero11 = (to_chars \\\"??\\\")\\n    let hero12 = (to_chars \\\"Za\\\")\\n    let hero13 = (to_chars \\\"Ag\\\")\\n    let hero14 = (to_chars \\\"Me\\\")\\n    let hero15 = (to_chars \\\"??\\\")\\n    let half00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]\\n    let half01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]\\n    let heroes = [half00, half01]\\n    (snd (take4 hero NilF heroes))\\n\\n  // Given a hero, returns its max life\\n  dup get_hero_max_life = # {hero}\\n    let hero00 = 60\\n    let hero01 = 40\\n    let hero02 = 40\\n    let hero03 = 0\\n    let hero04 = 20\\n    let hero05 = 20\\n    let hero06 = 20\\n    let hero07 = 0\\n    let hero08 = 30\\n    let hero09 = 30\\n    let hero10 = 30\\n    let hero11 = 0\\n    let hero12 = 1\\n    let hero13 = 10\\n    let hero14 = 10\\n    let hero15 = 0\\n    let half00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]\\n    let half01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]\\n    let heroes = [half00, half01]\\n    (snd (take4 hero NilF heroes))\\n\\n  // :::::::::::\\n  // :: Skill ::\\n  // :::::::::::\\n\\n  dup TOPHORO_WALK   = # 0\\n  dup EARTH_ROOT     = # 1\\n  dup EARTH_WALL     = # 2\\n  dup EARTH_RISE     = # 3\\n  dup GONK_WALK      = # 4\\n  dup EMPATHY        = # 5\\n  dup REVENGE        = # 6\\n  dup GROUND_SLAM    = # 7\\n  dup STANCI_WALK    = # 8\\n  dup RESTORE        = # 9\\n  dup ESCORT         = # 10\\n  dup DETAIN         = # 11\\n  dup ERKOS_WALK     = # 16\\n  dup FLAME_BALL     = # 17\\n  dup FLAME_WAVE     = # 18\\n  dup FLAME_NOVA     = # 19\\n  dup CRONI_WALK     = # 20\\n  dup SHADOW_BOND    = # 21\\n  dup SHADOW_TRAP    = # 22\\n  dup SHADOW_FLUX    = # 23\\n  dup SNARCH_WALK    = # 24\\n  dup BALLISTA       = # 25\\n  dup QUICK_BOLT_0   = # 26\\n  dup QUICK_BOLT_1   = # 27\\n  dup SIRPIX_WALK    = # 32\\n  dup STEALTH_MOVE   = # 33\\n  dup STEALTH_STRIKE = # 34\\n  dup LOCKPICK       = # 35\\n  dup KENLUA_WALK    = # 36\\n  dup HASTE          = # 37\\n  dup DODGE          = # 38\\n  dup SLASH          = # 39\\n  dup FLINA_WALK     = # 40\\n  dup JAVELIN        = # 41\\n  dup FLY            = # 42\\n  dup GUST           = # 43\\n  dup ZAGATUR_WALK   = # 48\\n  dup NEEDLE         = # 49\\n  dup WRAP           = # 50\\n  dup SUMMON         = # 51\\n  dup AGDRIS_WALK    = # 52\\n  dup PROTECT        = # 53\\n  dup SILENCE        = # 54\\n  dup MEMENTO        = # 55\\n  dup MEWEN_WALK     = # 56\\n  dup TELEPORT       = # 57\\n  dup PSYCHOCK       = # 58\\n  dup IMPRISON       = # 59\\n\\n  dup PRIORITY_LIST = #\\n    (Cons MEMENTO\\n    (Cons SILENCE\\n    (Cons PROTECT\\n    (Cons STEALTH_MOVE\\n    (Cons TELEPORT\\n    (Cons EARTH_ROOT\\n    (Cons SHADOW_BOND\\n    (Cons BALLISTA\\n    (Cons EMPATHY\\n    (Cons ESCORT\\n    (Cons RESTORE\\n    (Cons DETAIN\\n    (Cons HASTE\\n    (Cons STEALTH_STRIKE\\n    (Cons REVENGE\\n    (Cons JAVELIN\\n    (Cons QUICK_BOLT_0\\n    (Cons QUICK_BOLT_1\\n    (Cons EARTH_WALL\\n    (Cons SHADOW_TRAP\\n    (Cons WRAP\\n    (Cons KENLUA_WALK\\n    (Cons SIRPIX_WALK\\n    (Cons FLINA_WALK\\n    (Cons SNARCH_WALK\\n    (Cons ERKOS_WALK\\n    (Cons CRONI_WALK\\n    (Cons STANCI_WALK\\n    (Cons GONK_WALK\\n    (Cons TOPHORO_WALK\\n    (Cons AGDRIS_WALK\\n    (Cons MEWEN_WALK\\n    (Cons ZAGATUR_WALK\\n    (Cons FLY\\n    (Cons DODGE\\n    (Cons NEEDLE\\n    (Cons EARTH_RISE\\n    (Cons GROUND_SLAM\\n    (Cons GUST\\n    (Cons SLASH\\n    (Cons FLAME_WAVE\\n    (Cons FLAME_BALL\\n    (Cons FLAME_NOVA\\n    (Cons PSYCHOCK\\n    (Cons IMPRISON\\n    (Cons SHADOW_FLUX\\n    (Cons LOCKPICK\\n    (Cons SUMMON\\n    Nil))))))))))))))))))))))))))))))))))))))))))))))))\\n\\n  let get_skill_area = {skill}\\n    cpy skill = skill\\n    if |skill ==  2| then: 1\\n    else: if |skill ==  3| then: 1\\n    else: if |skill ==  5| then: 1\\n    else: if |skill ==  7| then: 2\\n    else: if |skill == 17| then: 2\\n    else: if |skill == 18| then: 1\\n    else: if |skill == 19| then: 6\\n    else: if |skill == 23| then: 1\\n    else: if |skill == 43| then: 1\\n    else: if |skill == 49| then: 1\\n    else: if |skill == 50| then: 1\\n    else: if |skill == 53| then: 2\\n    else: if |skill == 58| then: 1\\n    else: if |skill == 59| then: 1\\n    else: 0\\n\\n  dup get_skill_priority =\\n    dup build_array = (~64 #{state}\\n      get [array, state]  = state\\n      get [index, skills] = state\\n      get [skills, skill] = (pop 63 skills)\\n      cpy index           = index\\n      let array           = (write6 skill index array)\\n      [array, [|index + 1|, skills]])\\n    dup empty_array = (init6 #0)\\n    # {skill}\\n      let array = fst (build_array [empty_array, [0, PRIORITY_LIST]])\\n      snd (take6 skill 0 array)\\n\\n  // ::::::::::\\n  // :: Item ::\\n  // ::::::::::\\n\\n  dup WALL = # 0\\n  dup ROCK = # 1\\n  dup TRAP = # 2\\n\\n  // ::::::::::\\n  // :: Unit ::\\n  // ::::::::::\\n\\n  dup VOID = # 0\\n  dup ITEM = # 1\\n  dup GOAL = # 2\\n  dup HERO = # 3\\n\\n  // Unit getters\\n  dup get_unit_kind = # {unit} ||unit >> 30| & 0b00000011|\\n  dup get_unit_side = # {unit} ||unit >> 28| & 0b00000011|\\n  dup get_unit_type = # {unit} ||unit >> 26| & 0b00000011|\\n  dup get_unit_hero = # {unit} ||unit >> 24| & 0b00001111|\\n  dup get_unit_life = # {unit} ||unit >> 18| & 0b00111111|\\n  dup get_unit_defs = # {unit} ||unit >> 14| & 0b00001111|\\n  dup get_unit_eff1 = # {unit} ||unit >> 12| & 0b00000011|\\n  dup get_unit_lock = # {unit} ||unit >> 10| & 0b00000011|\\n  dup get_unit_mute = # {unit} ||unit >>  8| & 0b00000011|\\n  dup get_unit_spec = # {unit} ||unit >>  0| & 0b11111111|\\n\\n  // Unit setters\\n  dup set_unit_kind = # {kind unit} ||unit & 0b00111111111111111111111111111111| | ||kind & 0b00000011| << 30||\\n  dup set_unit_side = # {side unit} ||unit & 0b11001111111111111111111111111111| | ||side & 0b00000011| << 28||\\n  dup set_unit_type = # {type unit} ||unit & 0b11110011111111111111111111111111| | ||type & 0b00000011| << 26||\\n  dup set_unit_hero = # {hero unit} ||unit & 0b11110000111111111111111111111111| | ||hero & 0b00001111| << 24||\\n  dup set_unit_life = # {life unit} ||unit & 0b11111111000000111111111111111111| | ||life & 0b00111111| << 18||\\n  dup set_unit_defs = # {defs unit} ||unit & 0b11111111111111000011111111111111| | ||defs & 0b00001111| << 14||\\n  dup set_unit_eff1 = # {eff1 unit} ||unit & 0b11111111111111111100111111111111| | ||eff1 & 0b00000011| << 12||\\n  dup set_unit_lock = # {lock unit} ||unit & 0b11111111111111111111001111111111| | ||lock & 0b00000011| << 10||\\n  dup set_unit_mute = # {mute unit} ||unit & 0b11111111111111111111110011111111| | ||mute & 0b00000011| <<  8||\\n  dup set_unit_spec = # {spec unit} ||unit & 0b11111111111111111111111100000000| | ||spec & 0b11111111| <<  0||\\n\\n  // Unit mappers\\n  dup mut_unit_kind = # {func unit} cpy unit = unit (set_unit_kind (func (get_unit_kind unit)) unit)\\n  dup mut_unit_type = # {func unit} cpy unit = unit (set_unit_type (func (get_unit_type unit)) unit)\\n  dup mut_unit_side = # {func unit} cpy unit = unit (set_unit_side (func (get_unit_side unit)) unit)\\n  dup mut_unit_hero = # {func unit} cpy unit = unit (set_unit_hero (func (get_unit_hero unit)) unit)\\n  dup mut_unit_life = # {func unit} cpy unit = unit (set_unit_life (func (get_unit_life unit)) unit)\\n  dup mut_unit_defs = # {func unit} cpy unit = unit (set_unit_defs (func (get_unit_defs unit)) unit)\\n  dup mut_unit_eff1 = # {func unit} cpy unit = unit (set_unit_eff1 (func (get_unit_eff1 unit)) unit)\\n  dup mut_unit_lock = # {func unit} cpy unit = unit (set_unit_lock (func (get_unit_lock unit)) unit)\\n  dup mut_unit_mute = # {func unit} cpy unit = unit (set_unit_mute (func (get_unit_mute unit)) unit)\\n  dup mut_unit_spec = # {func unit} cpy unit = unit (set_unit_spec (func (get_unit_spec unit)) unit)\\n\\n  // Unit constructor\\n  dup Unit = # {kind}\\n    cpy kind = kind\\n    cpy unit = 0\\n    if |kind == VOID| then:\\n      let unit = (set_unit_kind VOID unit) \\n      let unit = (set_unit_side BOARD unit)\\n      unit\\n    else: if |kind == ITEM| then: {type}\\n      let unit = (set_unit_kind ITEM unit)\\n      let unit = (set_unit_side BOARD unit)\\n      let unit = (set_unit_type type unit)\\n      unit\\n    else: if |kind == GOAL| then: {side}\\n      let unit = (set_unit_kind GOAL unit)\\n      let unit = (set_unit_side side unit)\\n      unit\\n    else: if |kind == HERO| then: {side hero life defs eff1 lock mute spec}\\n      let unit = (set_unit_kind HERO unit)\\n      let unit = (set_unit_side side unit)\\n      let unit = (set_unit_hero hero unit)\\n      let unit = (set_unit_life life unit)\\n      let unit = (set_unit_defs defs unit)\\n      let unit = (set_unit_eff1 eff1 unit)\\n      let unit = (set_unit_lock lock unit)\\n      let unit = (set_unit_mute mute unit)\\n      let unit = (set_unit_spec spec unit)\\n      unit\\n    else:\\n      unit\\n\\n  // Void constructor\\n  dup Void = #\\n    (Unit VOID)\\n\\n  // Item constructor\\n  dup Item = # {type}\\n    (Unit ITEM type)\\n\\n  // Goal constructor\\n  dup Goal = # {side}\\n    (Unit GOAL side)\\n\\n  // Hero constructor\\n  dup Hero = # {side hero}\\n    cpy hero = hero\\n    (Unit HERO side hero (get_hero_max_life hero) 0 0 0 0 0)\\n\\n  // Unit kind pattern-matching\\n  dup match_unit_kind = # {unit case_void case_item case_goal case_hero}\\n    cpy unit = unit \\n    cpy kind = (get_unit_kind unit)\\n    if |kind == VOID| then:\\n      case_void\\n    else: if |kind == ITEM| then:\\n      case_item\\n    else: if |kind == GOAL| then:\\n      case_goal\\n    else: if |kind == HERO| then:\\n      case_hero\\n    else:\\n      0\\n\\n  dup unit_to_scott = # {unit}\\n    cpy unit      = unit\\n    let case_void = {Void Item Goal Hero}\\n      Void\\n    let case_item = {Void Item Goal Hero}\\n      (Item (get_unit_type unit))\\n    let case_goal = {Void Item Goal Hero}\\n      (Goal (get_unit_side unit))\\n    let case_hero = {Void Item Goal Hero}\\n      (Hero\\n        (get_unit_side unit)\\n        (get_unit_hero unit)\\n        (get_unit_life unit)\\n        (get_unit_defs unit)\\n        (get_unit_eff1 unit)\\n        (get_unit_lock unit)\\n        (get_unit_mute unit)\\n        (get_unit_spec unit))\\n    (match_unit_kind unit case_void case_item case_goal case_hero)\\n\\n  // Given a unit, returns its icon\\n  dup get_unit_icon = # {unit}\\n    cpy unit      = unit\\n    let case_void = (to_chars \\\" .\\\")\\n    let case_item = cpy t = (get_unit_type unit) if |t == WALL| [(to_chars \\\"[]\\\"), if |t == ROCK| [(to_chars \\\"()\\\"), (to_chars \\\" %\\\")]]\\n    let case_goal = (to_chars \\\"<>\\\")\\n    let case_unit = (get_hero_icon (get_unit_hero unit))\\n    (match_unit_kind unit case_void case_item case_goal case_unit)\\n\\n  // Given a unit, returns a readable stats line\\n  dup get_unit_info = # {unit}\\n    cpy unit      = unit\\n    let case_void = NilF\\n    let case_item = NilF\\n    let case_goal = NilF\\n    let case_hero =\\n      cpy hero = (get_unit_hero unit)\\n      cpy side = (get_unit_side unit)\\n      cpy life = (get_unit_life unit)\\n      cpy defs = (get_unit_defs unit)\\n      cpy eff1 = (get_unit_eff1 unit)\\n      cpy lock = (get_unit_lock unit)\\n      cpy mute = (get_unit_mute unit)\\n      cpy spec = (get_unit_spec unit)\\n      (concat (get_hero_icon hero) // Hero name\\n      (concat (to_chars \\\" | \\\")\\n      (concat (ConsF (box_byte (num_to_char ||life /  10| % 10|)) NilF) // life\\n      (concat (ConsF (box_byte (num_to_char ||life /   1| % 10|)) NilF) // life\\n      (concat (to_chars \\\" | \\\")\\n      (concat (ConsF (box_byte (num_to_char ||defs /  10| % 10|)) NilF) //defs \\n      (concat (ConsF (box_byte (num_to_char ||defs /   1| % 10|)) NilF) //defs \\n      (concat (to_chars \\\" | \\\")\\n      (concat (if side [(to_chars \\\"black \\\"),(to_chars \\\"white \\\")])\\n      (concat (if eff1 [(to_chars \\\"(eff1) \\\"), NilF])\\n      (concat (if lock [(to_chars \\\"(lock) \\\"), NilF])\\n      (concat (if mute [(to_chars \\\"(mute) \\\"), NilF])\\n      (concat (if spec [(to_chars \\\"(spec) \\\"), NilF])\\n              (ConsF #10 NilF))))))))))))))\\n    (match_unit_kind unit case_void case_item case_goal case_hero)\\n\\n  dup is_enemy = # {unit_a unit_b} (is_enemy_side (get_unit_side unit_a) (get_unit_side unit_b))\\n  dup is_ally  = # {unit_a unit_b} (is_ally_side  (get_unit_side unit_a) (get_unit_side unit_b))\\n\\n  // Adds an amount of life to an unit\\n  dup heal = # {add_life unit}\\n    cpy unit      = unit\\n    let case_void = unit\\n    let case_item = unit\\n    let case_goal = unit\\n    let case_hero =\\n      cpy add_life = add_life\\n      cpy has_life = (get_unit_life unit)\\n      cpy max_life = (get_hero_max_life (get_unit_hero unit))\\n      cpy new_life = |has_life + add_life|\\n      if |new_life > 2147483648| then: // damage > life\\n        Void\\n      else: if |new_life > max_life| then:\\n        (set_unit_life max_life unit)\\n      else:\\n        (set_unit_life new_life unit)\\n    (match_unit_kind unit case_void case_item case_goal case_hero)\\n    \\n  // Removes an amount of life of an unit\\n  dup dmge = # {dmg unit} (heal |0 - dmg| unit)\\n  dup mute = # {trn unit} (mut_unit_mute {mute}|mute + trn| unit)\\n  dup lock = # {trn unit} (mut_unit_lock {lock}|lock + trn| unit)\\n  dup defs = # {def unit} (mut_unit_defs {defs}|defs + def| unit)\\n\\n  dup if_unit = # {comp fun caster target}\\n    cpy caster = caster\\n    cpy target = target\\n    if (comp caster target)\\n    then: (fun caster target)\\n    else: [caster, target]\\n\\n  dup dmge_enemy = # {val} (if_unit is_enemy {caster target}\\n    // Gets caster and target\\n    cpy c_old  = caster\\n    cpy t_old  = target\\n\\n    // Gets hero and spec info\\n    cpy c_hero = (get_unit_hero c_old)\\n    cpy t_hero = (get_unit_hero t_old)\\n    cpy t_spec = (get_unit_spec t_old)\\n\\n    // Applies armor\\n    cpy dmg    = val\\n    cpy def    = (get_unit_defs t_old)\\n    cpy t_defs = if |def > dmg| [|def - dmg|, 0]\\n    cpy dmg    = if |def > dmg| [0, |dmg - def|]\\n\\n    // Applies DODGE\\n    cpy dmg    =\\n      if ||t_hero == KENLUA| & |t_spec == |c_hero + 128|||\\n      then: 0\\n      else: dmg\\n\\n    // Applies damage\\n    cpy t_new  = (dmge dmg (set_unit_defs t_defs t_old))\\n\\n    // Applies SHADOW_BOND\\n    cpy c_new  =\\n      if |||t_hero == CRONI| & |t_new == Void|| & |t_spec > 0||\\n      then: Void\\n      else: c_old\\n\\n    [c_new, t_new])\\n\\n  dup lock_enemy = # {val} (if_unit is_enemy {caster target} [caster, (lock val target)])\\n  dup mute_enemy = # {val} (if_unit is_enemy {caster target} [caster, (mute val target)])\\n  dup heal_ally  = # {val} (if_unit is_ally  {caster target} [caster, (heal val target)])\\n  dup defs_ally  = # {val} (if_unit is_ally  {caster target} [caster, (defs val target)])\\n\\n  // \\\"a\\\" and \\\"b\\\" are side positions. The function checks if they can swap their position, that is, simulate a walk, and returns:\\n  // - The same position: if they can't interact with each other.\\n  // - Inverted position: the elements interacted and one now occupies the position of the other.\\n  dup a_step_to_b = # {a b}\\n    cpy a             = a\\n    cpy b             = b\\n    let case_a_void   = [a, b]\\n    let case_a_item   = [a, b]\\n    let case_a_goal   = [a, b]\\n    let case_a_hero   =\\n      let case_b_void = [b, a]\\n      let case_b_item =\\n        // TODO: don't activate trap if it is from the same team (must add that info on the trap)\\n        if |(get_unit_type b) == TRAP|\\n          then: [Void, (lock 2 a)]\\n          else: [a, b]\\n      let case_b_goal = [a, b]\\n      let case_b_hero = \\n        cpy a_side    = (get_unit_side a)\\n        cpy b_side    = (get_unit_side b)\\n        if |a_side == b_side|\\n          then: [b, a]\\n          else: [a, b]\\n      (match_unit_kind b case_b_void case_b_item case_b_goal case_b_hero)\\n    (match_unit_kind a case_a_void case_a_item case_a_goal case_a_hero)\\n\\n  // :::::::::::\\n  // :: Board ::\\n  // :::::::::::\\n\\ndup new_board = #\\n    //let O   = Void\\n    //let W   = (Item WALL)\\n    //let a   = (Hero WHITE GONK)\\n    //let b   = (Hero WHITE ERKOS)\\n    //let c   = (Hero WHITE KENLUA)\\n    //let d   = (Hero WHITE MEWEM)\\n    //let x   = (Goal WHITE)\\n    //let e   = (Hero BLACK TOPHORO)\\n    //let f   = (Hero BLACK CRONI)\\n    //let g   = (Hero BLACK FLINA)\\n    //let h   = (Hero BLACK STANCI)\\n    //let y   = (Goal BLACK)\\n    //let r00 = [[[[W,W],[W,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[h,W],[W,W]]]]\\n    //let r01 = [[[[W,W],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,g],[y,W]]]]\\n    //let r02 = [[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[f,W]]]]\\n    //let r03 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,e]]]]\\n    //let r04 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r05 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r06 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r07 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r08 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r09 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r10 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r11 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r12 = [[[[a,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r13 = [[[[W,b],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]\\n    //let r14 = [[[[W,x],[c,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[W,W]]]]\\n    //let r15 = [[[[W,W],[W,d]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,W],[W,W]]]]\\n    //[[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]]\\n\\n    let O   = Void\\n    let W   = (Item WALL)\\n    let a   = (Hero WHITE GONK)\\n    let b   = (Hero WHITE STANCI)\\n    let c   = (Hero WHITE ERKOS)\\n    let d   = (Hero WHITE KENLUA)\\n    let x   = (Goal WHITE)\\n    let e   = (Hero BLACK TOPHORO)\\n    let f   = (Hero BLACK CRONI)\\n    let g   = (Hero BLACK SNARCH)\\n    let h   = (Hero BLACK MEWEM)\\n    let y   = (Goal BLACK)\\n    let r00 = [[[[W,W],[W,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[h,W],[W,W]]]]\\n    let r01 = [[[[W,W],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,g],[y,W]]]]\\n    let r02 = [[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[f,W]]]]\\n    let r03 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,e]]]]\\n    let r04 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r05 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r06 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r07 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r08 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r09 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r10 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r11 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r12 = [[[[a,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r13 = [[[[W,b],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]\\n    let r14 = [[[[W,x],[c,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[W,W]]]]\\n    let r15 = [[[[W,W],[W,d]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,W],[W,W]]]]\\n    [[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]]\\n\\n  // Converts a 16x16 position to an index up to 256.\\n  dup board_index = # {pos}\\n    get [x,y] = pos\\n    cpy x     = x\\n    cpy y     = y\\n    cpy o     = ||x > 15| | |y > 15||\\n    let x     = if o [0, x]\\n    let y     = if o [0, y]\\n    ||y * 16| + x|\\n\\n  // Converts an index up to 256 to a 16x16 position.\\n  dup board_position = # {idx}\\n    cpy idx = idx\\n    [|idx % 16|, |idx / 16|]\\n\\n  dup board_interact = # {a_pos b_pos}\\n    cpy a_idx = (board_index a_pos)\\n    cpy b_idx = (board_index b_pos)\\n    if |a_idx == b_idx|\\n      then: {fun board}\\n        get [board,b_val] = (take8 b_idx Void board)\\n        cpy b_val         = b_val\\n        get [a_val,b_val] = (fun b_val b_val)\\n        let board         = (write8 b_idx b_val board)\\n        board\\n      else: {fun board}\\n        get [board,a_val] = (take8 a_idx Void board)\\n        get [board,b_val] = (take8 b_idx Void board)\\n        get [a_val,b_val] = (fun a_val b_val)\\n        let board         = (write8 a_idx a_val board)\\n        let board         = (write8 b_idx b_val board)\\n        board \\n\\n  dup board_swap = # {a_pos b_pos board}\\n    (board_interact a_pos b_pos {a b}[b,a] board)\\n\\n  // Apply a function to a board unit\\n  dup board_update = # {pos fun board}\\n    (update8 (board_index pos) fun board)\\n\\n  dup print_board = \\n    let NEWLINE = 10\\n    let SPACE   = 32\\n    let break_lines = {list Cons}\\n      dup Cons = Cons\\n      dup fold = (list #{x xs i}\\n        cpy i = i\\n        (if |i == 0| then:\\n          {list} (Cons NEWLINE list)\\n        else: if ||i % 32| == 0| then:\\n          {list} (Cons SPACE (Cons (num_to_char ||i - 1| / 32|) (Cons NEWLINE list)))\\n        else:\\n          {list} list\\n        (Cons x (xs |i + 1|))))\\n      # {Nil} (fold {i}(Cons SPACE (Cons (num_to_char 15) Nil)) 0)\\n    let fold_node = {lft rgt}\\n      get [lft_info, lft_board] = lft\\n      get [rgt_info, rgt_board] = rgt\\n      [(concat lft_info rgt_info), (concat lft_board rgt_board)]\\n    let fold_leaf = {unit}\\n      cpy unit = unit\\n      [(get_unit_info unit), (get_unit_icon unit)]\\n    dup fold = (fold8 #fold_node #fold_leaf)\\n    # {board}\\n      get [info_text, board_text] = (fold board)\\n      (from_chars\\n        (concat (ConsF NEWLINE NilF)\\n        (concat (to_chars \\\" 0 1 2 3 4 5 6 7 8 9 a b c d e f\\\")\\n        (concat (break_lines board_text)\\n        (concat (ConsF NEWLINE NilF)\\n        (concat (to_chars \\\"HR | HP | DF |\\\")\\n        (concat (ConsF NEWLINE NilF)\\n        (concat (to_chars \\\"-- | -- | -- |\\\")\\n        (concat (ConsF NEWLINE NilF)\\n        (concat info_text\\n          (ConsF NEWLINE NilF)))))))))))\\n\\n  // get_hero_position\\n  // | Returns the position of a hero on the board, if any\\n  // | TODO: board should remember hero positions to avoid searching\\n  // : {hero : HeroID} ->\\n  //   {board : (Array ~8 Unitt)} ->\\n  //   [(Array ~8 Unit), (Maybe [Num,Num])]\\n  dup get_hero_position =\\n    let fold_node = {lft rgt her idx}\\n      cpy idx                  = idx\\n      cpy her                  = her\\n      get [lft_board, lft_pos] = (lft her |idx * 2|)\\n      get [rgt_board, rgt_pos] = (rgt her ||idx * 2| + 1|)\\n      [[lft_board, rgt_board], (maybe_concat lft_pos rgt_pos)]\\n    let fold_leaf = {unit her idx}\\n      cpy unit = unit\\n      if ||(get_unit_kind unit) == HERO| & |(get_unit_hero unit) == her||\\n        then: [unit, (Just (board_position idx))]\\n        else: [unit, None]\\n    dup find = (fold8 #fold_node #fold_leaf)\\n    # {hero board}\\n      (find board hero 0)\\n\\n  dup query_at = # {pos func board}\\n    let cpy_app_func = {unit}\\n      cpy unit = unit\\n      [unit, (func unit)]\\n    (with8 (board_index pos) cpy_app_func board)\\n\\n  dup get_at = # {pos board}\\n    (query_at pos {x}x board)\\n\\n  dup is_void_at  = # {pos board} (query_at pos {unit}|(get_unit_kind unit) == VOID| board)\\n  dup is_item_at  = # {pos board} (query_at pos {unit}|(get_unit_kind unit) == WALL| board)\\n  dup is_goal_at  = # {pos board} (query_at pos {unit}|(get_unit_kind unit) == GOAL| board)\\n  dup is_hero_at  = # {pos hero board} (query_at pos ({unit} cpy unit = unit ||(get_unit_kind unit) == HERO| & |(get_unit_hero unit) == hero||) board)\\n  dup get_lock_at = # {pos board} (query_at pos get_unit_lock board)\\n  dup get_mute_at = # {pos board} (query_at pos get_unit_mute board)\\n  dup get_side_at = # {pos board} (query_at pos get_unit_side board)\\n  dup get_life_at = # {pos board} (query_at pos get_unit_life board)\\n  dup get_defs_at = # {pos board} (query_at pos get_unit_defs board)\\n  dup comp_side = # {comp a_pos b_pos board}\\n    get [board, a_side] = (get_side_at a_pos board)\\n    get [board, b_side] = (get_side_at b_pos board)\\n    [board, (comp a_side b_side)]\\n  dup are_enemies_at = # (comp_side {a b}|a == b|)\\n  dup are_allies_at = # (comp_side {a b}|a == b|)\\n\\n  // :::::::::::::\\n  // :: Effects ::\\n  // :::::::::::::\\n\\n  // Given a position and a direction to step forward, move the element (if is possible) and return the updated map\\n  dup step = # {a_pos a_dxy board}\\n    get [a_pos0,a_pos1] = (vec2_cpy a_pos)\\n    let b_pos           = (vec2_add a_pos0 a_dxy)\\n    (board_interact a_pos1 b_pos a_step_to_b board)\\n\\n  // cast_area\\n  // : {-P    : Type}\\n  //   {range : Num}\\n  //   {area  : Area}\\n  //   {hits  : {cpos : [Num,Num]} {hpos : [Num,Num]} {state : P} P}\\n  // ! {pos   : [Num,Num]}\\n  //   {dirs  : (SList [Num,Num])}\\n  //   {state : P}\\n  //   P\\n  let cast_area = {range area hits}\\n    dup range = range\\n    dup hits  = hits\\n    dup exec  = (area #{hpos state}\\n      get [state, cpos]  = state\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      get [hpos0, hpos1] = (vec2_cpy hpos)\\n      let new_state      = (hits cpos0 hpos0 state)\\n      [new_state, cpos1])\\n    # {cpos tpos}\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      get [tpos0, tpos1] = (vec2_cpy tpos)\\n      if |(vec2_flat_dist cpos0 tpos0) < |range + 1||\\n      then: {state} (fst (exec tpos1 [state, cpos1]))\\n      else: {state} state\\n\\n  // cast_wave\\n  // : {-P    : Type}\\n  //   {area  : Area}\\n  //   {hits  : {cpos : [Num,Num]} {tpos : [Num,Num]} {dir : [Num,Num]} {state : P} P}\\n  // ! {pos   : [Num,Num]}\\n  //   {dir   : [Num,Num]}\\n  //   {state : P}\\n  //   P\\n  let cast_wave = {area hits}\\n    dup hits = hits\\n    dup exec = (area #{hpos_dir state}\\n      get [hpos, dir]    = hpos_dir\\n      get [state, cpos]  = state\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      get [hpos0, hpos1] = (vec2_cpy hpos)\\n      let new_state      = (hits cpos0 hpos0 dir state)\\n      [new_state, cpos1])\\n    # {pos dir state}\\n      get [cpos0, cpos1] = (vec2_cpy pos)\\n      get [state, cpos]  = (exec cpos0 dir [state, cpos1])\\n      state\\n\\n  // Walks through a set of directions\\n  let walk = {range}\\n    let rang = range\\n    let area = vec2_range_0\\n    let hits = {cpos tpos board}\\n      let effect = {caster target}\\n        cpy caster = caster\\n        cpy target = target\\n        cpy c_lock = (get_unit_lock caster)\\n        cpy c_hero = (get_unit_hero caster)\\n        cpy c_spec = (get_unit_spec caster)\\n        cpy locked = |c_lock | ||c_hero == SNARCH| & |c_spec > 0|||\\n        if locked\\n        then: [caster, target]\\n        else: (a_step_to_b caster target)\\n      (board_interact cpos tpos effect board)\\n    (cast_area rang area #hits)\\n\\n  // == Tophoro ==\\n  // ~~~~~~~~~~~~~\\n\\n  dup tophoro_walk = (walk #3)\\n\\n  dup earth_root = (cast_area #32 vec2_range_0 # {cpos tpos board}\\n    (board_update cpos {unit}(heal 20 (mute 3 (lock 3 unit))) board))\\n\\n  dup earth_rise =\\n    let rang = #2\\n    let area = vec2_range_1\\n    let hits = #{cpos tpos board} \\n      let effect = {caster target}\\n        get [caster, target] = (dmge_enemy 2 caster target)\\n        get [caster, target] = (mute_enemy 1 caster target)\\n        [caster, target]\\n      (board_interact cpos tpos effect board)\\n    (cast_area rang area hits)\\n\\n  dup earth_wall =\\n    let rang = #2\\n    let area = vec2_range_1\\n    let wall = {unit}\\n      cpy unit = unit\\n      if |(get_unit_kind unit) == VOID|\\n      then: (Item ROCK)\\n      else: unit\\n    let hits = {cpos tpos board}\\n      (board_update tpos wall board)\\n    (cast_area #2 area #hits)\\n\\n  let test_earth_root = \\n    let board = new_board\\n    let board = (board_update [0xf,0x3] (dmge 50) board)\\n    let board = (earth_root [0xf,0x3] [0xf,0x3] board)\\n    (print_board board)\\n\\n  let test_earth_rise = \\n    let board = new_board\\n    let board = (board_swap [0x3,0xf] [0xf,0x5] board)\\n    let board = (earth_rise [0xf,0x3] [0xf,0x4] board)\\n    (print_board board)\\n\\n  let test_earth_wall =\\n    let board = new_board\\n    let board = (board_swap [0x3,0xf] [0xf,0x5] board)\\n    let board = (earth_wall [0xf,0x3] [0xe,0x4] board)\\n    (print_board board)\\n\\n  // == Gonk ==\\n  // ~~~~~~~~~~\\n\\n  dup gonk_walk = (walk #3)\\n\\n  dup empathy = \\n    let rang = #1\\n    let area = vec2_range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (defs_ally 5) board)\\n    dup cast = (cast_area rang area hits)\\n    # {cpos tpos board}\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      let board          = (cast cpos1 tpos board)\\n      let board          = (board_update cpos0 (dmge 2) board)\\n      board\\n\\n  dup revenge =\\n    let rang = #1\\n    let area = vec2_range_0\\n    let hits = #{cpos tpos board}\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      get [board, life]  = (get_life_at cpos0 board)\\n      let effect         = (dmge_enemy ||40 - life| / 4|)\\n      (board_interact cpos1 tpos effect board)\\n    (cast_area rang area hits)\\n\\n  dup ground_slam =\\n    let rang = #0\\n    let area = vec2_range_2\\n    let hits = #{cpos tpos board}\\n      get [tpos0, tpos1] = (vec2_cpy tpos)\\n      let effect         = {caster target}\\n        get [caster, target] = (dmge_enemy 2 caster target)\\n        get [caster, target] = (mute_enemy 1 caster target)\\n        [caster, target]\\n      (board_interact cpos tpos1 effect board)\\n    (cast_area rang area hits)\\n\\n  let test_empathy =\\n    let board = new_board\\n    let board = (gonk_walk [0x0,0xc] [0x2,0xc] board)\\n    let board = (board_swap [0xf,0x3] [0x5,0xe] board)\\n    let board = (empathy [0x2,0xc] [0x2,0xd] board)\\n    let board = (earth_rise [0x5,0xe] [0x3,0xe] board)\\n    let board = (earth_rise [0x5,0xe] [0x3,0xe] board)\\n    let board = (earth_rise [0x5,0xe] [0x3,0xe] board)\\n    (print_board board)\\n\\n  let test_revenge =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xf,0x4] board)\\n    let board = (board_update [0xf,0x4] (dmge 32) board)\\n    let board = (revenge [0xF,0x4] [0xF,0x3] board)\\n    (print_board board)\\n\\n  let test_ground_slam =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xe,0x3] board)\\n    let board = (ground_slam [0xe,0x3] [0xe,0x3] board)\\n    (print_board board)\\n\\n  // == Stanci ==\\n  // ~~~~~~~~~~~~\\n\\n  dup stanci_walk = (walk #3)\\n\\n  dup restore =\\n    let rang = #3\\n    let area = vec2_range_0\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (heal_ally 3) board)\\n    (cast_area rang area hits)\\n\\n  dup escort =\\n    let rang = #3\\n    let area = vec2_range_0\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (defs_ally 3) board)\\n    (cast_area rang area hits)\\n\\n  dup detain =\\n    let rang = #3\\n    let area = vec2_range_0\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (mute_enemy 1) board)\\n    (cast_area rang area hits)\\n\\n  let test_restore =\\n    let board = new_board\\n    let board = (board_update [0xe,0x2] (dmge 10) board)\\n    let board = (restore [0xd,0x1] [0xe,0x2] board)\\n    (print_board board)\\n\\n  let test_escort =\\n    let board = new_board\\n    let board = (escort [0xd,0x1] [0xe,0x2] board)\\n    (print_board board)\\n\\n  let test_detain =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xc,0x2] board)\\n    let board = (detain [0xd,0x1] [0xc,0x2] board)\\n    (print_board board)\\n\\n  // == Erkos ==\\n  // ~~~~~~~~~~~\\n\\n  dup erkos_walk = (walk #3)\\n\\n  dup flame_ball =\\n    let rang = #3\\n    let area = vec2_range_2\\n    let hits = # {cpos hpos board} (board_interact cpos hpos (dmge_enemy 3) board)\\n    (cast_area rang area hits)\\n\\n  dup flame_wave =\\n    let rang = #3\\n    let area = vec2_range_1\\n    let hits = # {cpos hpos board} (board_interact cpos hpos (dmge_enemy 5) board)\\n    (cast_area rang area hits)\\n\\n  dup flame_nova = \\n    let rang = #0\\n    let area = vec2_range_6\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (dmge_enemy 15) board)\\n    dup cast = (cast_area rang area hits)\\n    # {cpos tpos board}\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      get [cpos2, cpos3] = (vec2_cpy cpos0)\\n      let board          = (cast cpos2 cpos3 board)\\n      let board          = (board_update cpos1 (dmge 30) board)\\n      board\\n\\n  let test_flame_ball =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xd,0x5] board)\\n    let board = (flame_ball [0xd,0x5] [0xd,0x3] board)\\n    (print_board board)\\n\\n  let test_flame_wave =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xd,0x5] board)\\n    let board = (flame_wave [0xd,0x5] [0xd,0x2] board)\\n    (print_board board)\\n\\n  let test_flame_nova =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xd,0x5] board)\\n    let board = (flame_nova [0xd,0x5] 12 board)\\n    (print_board board)\\n\\n  // == Croni ==\\n  // ~~~~~~~~~~~\\n\\n  dup croni_walk = (walk #3)\\n\\n  dup shadow_bond = # {pos nil board}\\n    let bind = {unit}\\n      let unit = (dmge 3 unit)\\n      let unit = (set_unit_spec 1 unit)\\n      unit\\n    (board_update pos bind board)\\n\\n  dup shadow_trap = \\n    let rang = #6\\n    let area = vec2_range_0\\n    let hits = #{cpos hpos board}\\n      let put_trap = {unit}\\n        cpy unit = unit\\n        if |(get_unit_kind unit) == VOID|\\n        then: (Item TRAP)\\n        else: unit\\n      (board_update hpos put_trap board)\\n    (cast_area rang area hits)\\n\\n  dup shadow_flux =\\n    let rang = #6\\n    let area = vec2_range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (dmge_enemy 8) board)\\n    (cast_area rang area hits)\\n\\n  let test_shadow_trap =\\n    let board = new_board\\n    let board = (board_swap [0xe,0x2] [0xa,0xd] board)\\n    let board = (shadow_trap [0xa,0xd] [0x2,0xd] board)\\n    let board = (erkos_walk [0x1,0xd] [0x2,0xd] board)\\n    (print_board board)\\n\\n  let test_shadow_bond =\\n    let board = new_board\\n    let board = (shadow_bond [0xe,0x2] [0,0] board)\\n    let board = (board_swap [0x1,0xd] [0xe,0x3] board)\\n    let board = (board_update [0xe,0x2] (dmge 16) board)\\n    let board = (flame_wave [0xe,0x3] [0xe,0x2] board)\\n    (print_board board)\\n\\n  // == Snarch ==\\n  // ~~~~~~~~~~~~\\n\\n  dup snarch_walk = (walk #3)\\n\\n  dup ballista = # {pos nil board}\\n    let mount = {unit}\\n      cpy unit = unit\\n      let spec = (get_unit_spec unit)\\n      let unit = (mut_unit_lock {x}|x + 1| unit)\\n      let unit = (mut_unit_mute {x}|x + 1| unit)\\n      let unit = (set_unit_spec |1 - spec| unit)\\n      unit\\n    (board_update pos mount board)\\n\\n  dup quick_bolt_0 =\\n    let area = vec2_range_1\\n    let hits = #{cpos hpos} (board_interact cpos hpos (dmge_enemy 2))\\n    let rngX = {rng} (cast_area rng area hits)\\n    dup rngA = (rngX #6)\\n    dup rngB = (rngX #12)\\n    # {cpos hpos board}\\n      get [cpos0, cpos1]   = (vec2_cpy cpos)\\n      get [board, mounted] = (query_at cpos0 get_unit_spec board) \\n      (if mounted [rngB, rngA] cpos1 hpos board)\\n\\n  dup quick_bolt_1 = # quick_bolt_0\\n\\n  let test_quick_bolt_0 =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0x4]) (Hero BLACK SNARCH) board)\\n    let board = (quick_bolt_0 [0xd,0x4] [0xd,0x1] board)\\n    (print_board board)\\n\\n  let test_ballista =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0xd]) (Hero WHITE SNARCH) board)\\n    let board = (ballista [0xd,0xd] 0 board)\\n    let board = (board_update [0xd,0xd] (set_unit_lock 0) board)\\n    let board = (board_update [0xd,0xd] (set_unit_mute 0) board)\\n    let board = (quick_bolt_0 [0xd,0xd] [0xd,0x1] board)\\n    let board = (snarch_walk [0xd,0xd] [0xd,0xe] board)\\n    (print_board board)\\n\\n  // == Sirpix ==\\n  // ~~~~~~~~~~~~\\n\\n  dup sirpix_walk = (walk #3)\\n\\n  dup stealth_move = # {cpos tpos board}\\n    get [cx, cy]      = cpos\\n    get [tx, ty]      = tpos\\n    cpy cx            = cx\\n    cpy cy            = cy\\n    cpy tx            = tx\\n    cpy ty            = ty\\n    get [board, spec] = (query_at [cx,cy] get_unit_spec board)\\n    cpy spec          = spec\\n    cpy spec          = if |spec == 0| [||cy << 4| | cx|, spec]\\n    cpy sx            = ||spec >> 0| & 0b1111|\\n    cpy sy            = ||spec >> 4| & 0b1111|\\n    (if |(vec2_flat_dist [sx,sy] [tx,ty]) < |4 + 1||\\n      then: {board} (board_update [cx,cy] (set_unit_spec ||ty << 4| | tx|) board)\\n      else: {board} board\\n      board)\\n\\n    dup stealth_strike =\\n      let rang = #0\\n      let area = vec2_range_1\\n      let hits = {cpos hpos} (board_interact cpos hpos (dmge_enemy 3))\\n      let cast = (cast_area rang area hits)\\n      # {cpos nil board}\\n          get [cx, cy]      = cpos\\n          cpy cx            = cx\\n          cpy cy            = cy\\n          get [board, spec] = (query_at [cx,cy] get_unit_spec board)\\n          cpy spec          = spec\\n          cpy spec          = if |spec == 0| [||cy << 4| | cx|, spec]\\n          cpy sx            = ||spec >> 0| & 0b1111|\\n          cpy sy            = ||spec >> 4| & 0b1111|\\n          get [board, void] = (is_void_at [sx,sy] board)\\n          (if void\\n            then: {board}\\n              let board = (board_update [cx,cy] (set_unit_spec ||cy << 4| | cx|) board)\\n              let board = (board_swap [cx,cy] [sx,sy] board)\\n              let board = (cast [sx,sy] [sx,sy] board)\\n              board\\n            else: {board}\\n              board\\n            board)\\n\\n  dup lockpick = # {cpos nil board}\\n    board\\n\\n  let test_stealth =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0xd]) (Hero BLACK SIRPIX) board)\\n    let board = (stealth_move [0xd,0xd] [0xd,0x9] board)\\n    let board = (stealth_move [0xd,0xd] [0xd,0x5] board)\\n    let board = (stealth_move [0xd,0xd] [0xd,0x2] board)\\n    let board = (stealth_strike [0xd,0xd] 0 board)\\n    (print_board board)\\n\\n  // == Kenlua ==\\n  // ~~~~~~~~~~~~\\n\\n  dup kenlua_walk = (walk #3)\\n\\n  dup haste =\\n    let rang = #0\\n    let area = vec2_range_1\\n    let hits = # {cpos tpos} (board_interact cpos tpos (dmge_enemy 4))\\n    dup strike = (cast_area rang area hits)\\n    # {cpos tpos board}\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      get [tposA, tposB] = (vec2_cpy tpos)\\n      get [tpos0, tpos1] = (vec2_cpy tposA)\\n      get [tpos2, tpos3] = (vec2_cpy tposB)\\n      get [board, void]  = (is_void_at tpos0 board)\\n      (if void\\n        then: {board}\\n          let board = (board_update cpos0 (dmge 2) board)\\n          let board = (board_swap cpos1 tpos1 board)\\n          let board = (strike tpos2 tpos3 board)\\n          board\\n        else: {board}\\n          board\\n        board)\\n\\n  dup dodge =\\n    let rang = #32\\n    let area = vec2_range_0\\n    let hits = #{cpos tpos board}\\n      let effect = {caster target}\\n        cpy caster = caster\\n        cpy target = target\\n        let caster = if |(get_unit_kind target) == HERO|\\n          then: (set_unit_spec |(get_unit_hero target) + 128| caster)\\n          else: caster\\n        [caster, target]\\n      (board_interact cpos tpos effect board)\\n    (cast_area rang area hits)\\n\\n  dup slash =\\n    let rang = #1\\n    let area = vec2_range_0\\n    let hits = # {cpos tpos} (board_interact cpos tpos (dmge_enemy 16))\\n    (cast_area rang area hits)\\n\\n  let test_haste =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0x8]) (Hero WHITE KENLUA) board)\\n    let board = (kenlua_walk [0xd,0x8] [0xd,0x5] board)\\n    let board = (haste [0xd,0x5] [0xd,0x2] board)\\n    (print_board board)\\n\\n  let test_dodge =\\n    let board = new_board\\n    let board = (board_swap [0xf,0x3] [0x4,0xe] board)\\n    let board = (board_swap [0xe,0x2] [0x6,0xe] board)\\n    let board = (dodge [0x2,0xe] [0x4,0xe] board)\\n    let board = (earth_rise [0x4,0xe] [0x2,0xe] board)\\n    let board = (shadow_flux [0x6,0xe] [0x2,0xe] board)\\n    (print_board board)\\n\\n  let test_slash =\\n    let board = new_board\\n    let board = (write8 (board_index [0xe,0x3]) (Hero WHITE KENLUA) board)\\n    let board = (board_update [0xe,0x3] (dmge 20) board)\\n    let board = (slash [0xe,0x3] [0xf,0x3] board)\\n    (print_board board)\\n\\n  // == Flina ==\\n  // ~~~~~~~~~~~\\n\\n  dup flina_walk = (walk #3)\\n\\n  dup javelin =\\n    let rang = #2\\n    let area = vec2_range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos (dmge_enemy 4))\\n    (cast_area rang area #hits)\\n\\n  dup fly =\\n    let rang = #3\\n    let area = vec2_range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos a_step_to_b)\\n    (cast_area rang area #hits)\\n\\n  dup gust =\\n    let rang = #2\\n    let area = vec2_range_1\\n    let hits = # {cpos hpos board} (board_interact cpos hpos (dmge_enemy 3) board)\\n    (cast_area rang area hits)\\n\\n  let test_javelin =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xa,0x0] board)\\n    let board = (javelin [0xc,0x0] [0xa,0x0] board)\\n    (print_board board)\\n\\n  let test_fly =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xa,0x2] board)\\n    let board = (fly [0xc,0x0] [0xa,0x2] board)\\n    (print_board board)\\n\\n  // == Zagatur ==\\n  // ~~~~~~~~~~~~~\\n\\n  dup zagatur_walk = (walk #0)\\n\\n  dup wrap =\\n    let rang = #0\\n    let area = vec2_range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (lock_enemy 1) board)\\n    (cast_area rang area hits)\\n\\n  dup needle =\\n    let rang = #0\\n    let area = vec2_range_1\\n    let hits = # {cpos tpos board} (board_interact cpos tpos (dmge_enemy 3) board)\\n    (cast_area rang area hits)\\n\\n  dup summon =\\n    let rang = #4\\n    let area = vec2_range_0\\n    let hits = {cpos tpos board}\\n      let effect = {caster target}\\n        cpy caster = caster\\n        cpy target = target\\n        let target = if |(get_unit_kind target) == VOID|\\n          then: (Hero (get_unit_side caster) ZAGATUR)\\n          else: target\\n        [caster, target]\\n      (board_interact cpos tpos effect board)\\n    (cast_area #2 vec2_range_0 #hits)\\n\\n  let test_summon =\\n    let board = new_board\\n    let board = (write8 (board_index [0x3,0xe]) (Hero BLACK ZAGATUR) board)\\n    let board = (summon [0x3,0xe] [0x5,0xe] board)\\n    let board = (needle [0x3,0xe] [0x3,0xe] board)\\n    let board = (wrap [0x3,0xe] [0x3,0xe] board)\\n    (print_board board)\\n\\n  // == Agdris ==\\n  // ~~~~~~~~~~~~\\n\\n  dup agdris_walk = (walk #1)\\n\\n  dup silence =\\n    let rang = #32\\n    let area = vec2_range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos (mute_enemy 1))\\n    (cast_area rang area #hits)\\n\\n  dup protect =\\n    let rang = #32\\n    let area = vec2_range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos (defs_ally 3))\\n    (cast_area rang area #hits)\\n\\n  dup memento =\\n    let rang = #32\\n    let area = vec2_range_2\\n    let hit0 = # {cpos tpos} (board_interact cpos tpos (mute_enemy 1))\\n    let hit1 = # {cpos tpos} (board_interact cpos tpos (lock_enemy 1))\\n    let hit2 = # {cpos tpos} (board_interact cpos tpos (dmge_enemy 2))\\n    let hit3 = # {cpos tpos} (board_interact cpos tpos (defs_ally 2))\\n    let hit4 = # {cpos tpos} (board_interact cpos tpos (heal_ally 2))\\n    dup eff0 = (cast_area rang area hit0)\\n    dup eff1 = (cast_area rang area hit1)\\n    dup eff2 = (cast_area rang area hit2)\\n    dup eff3 = (cast_area rang area hit3)\\n    dup eff4 = (cast_area rang area hit4)\\n    # {cpos tpos board}\\n      get [cx, cy] = cpos\\n      get [tx, ty] = tpos\\n      cpy cx       = cx\\n      cpy cy       = cy\\n      cpy tx       = tx\\n      cpy ty       = ty\\n      let board    = (eff0 [cx,cy] [tx,ty] board)\\n      let board    = (eff1 [cx,cy] [tx,ty] board)\\n      let board    = (eff2 [cx,cy] [tx,ty] board)\\n      let board    = (eff3 [cx,cy] [tx,ty] board)\\n      let board    = (eff4 [cx,cy] [tx,ty] board)\\n      let board    = (board_update [cx,cy] (dmge 63) board)\\n      board\\n\\n  let test_silence =\\n    let board = new_board\\n    let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n    let board = (silence [0x2,0xd] [0xc,0x0] board)\\n    (print_board board)\\n\\n  let test_protect =\\n    let board = new_board\\n    let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n    let board = (protect [0x2,0xd] [0x0,0xc] board)\\n    (print_board board)\\n\\n  let test_memento =\\n    let board = new_board\\n    let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n    let board = (board_swap [0xe,0x2] [0x3,0xd] board)\\n    let board = (board_swap [0xd,0x1] [0x2,0xc] board)\\n    let board = (memento [0x2,0xd] [0x2,0xd] board)\\n    (print_board board)\\n\\n  // == Mewem ==\\n  // ~~~~~~~~~~~\\n\\n  dup mewem_walk = (walk #0)\\n\\n  dup teleport =\\n    let rang = #32\\n    let area = vec2_range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos a_step_to_b)\\n    (cast_area rang area #hits)\\n\\n  dup psychock =\\n    let rang = #4\\n    let area = vec2_range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (dmge_enemy 6) board)\\n    (cast_area rang area hits)\\n\\n  dup imprison =\\n    let rang = #4\\n    let area = vec2_range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (lock_enemy 2) board)\\n    (cast_area rang area hits)\\n\\n  // == That's all! ==\\n  // ~~~~~~~~~~~~~~~~~\\n\\n  dup get_skill_effect = # {skill}\\n    let to = [[tophoro_walk , earth_root]   , [earth_wall     , earth_rise]]\\n    let go = [[gonk_walk    , empathy]      , [revenge        , ground_slam]]\\n    let st = [[stanci_walk  , restore]      , [escort         , detain]]\\n    let h3 = 0\\n    let er = [[erkos_walk   , flame_ball]   , [flame_wave     , flame_nova]]\\n    let cr = [[croni_walk   , shadow_bond]  , [shadow_trap    , shadow_flux]]\\n    let sn = [[snarch_walk  , ballista]     , [quick_bolt_0   , quick_bolt_1]]\\n    let h7 = 0\\n    let si = [[sirpix_walk  , stealth_move] , [stealth_strike , lockpick]]\\n    let ke = [[kenlua_walk  , haste]        , [dodge          , slash]]\\n    let fl = [[flina_walk   , javelin]      , [fly            , gust]]\\n    let hB = 0\\n    let za = [[zagatur_walk , needle]       , [wrap           , summon]]\\n    let ag = [[agdris_walk  , protect]      , [silence        , memento]]\\n    let me = [[mewem_walk   , teleport]     , [psychock       , imprison]]\\n    let hF = 0\\n    let r0 = [[[to,go],[st,h3]],[[er,cr],[sn,h7]]]\\n    let r1 = [[[si,ke],[fl,hB]],[[za,ag],[me,hF]]]\\n    (snd (take6 skill 0 [r0, r1]))\\n\\n  // :::::::::::\\n  // :: Casts ::\\n  // :::::::::::\\n\\n  // empty_cast\\n  dup empty_cast = # Nil\\n\\n  let sort_casts = {casts} {Cons}\\n   dup Cons = Cons\\n   dup arr = (init6 #{Nil} Nil)\\n   let loop = {cast arr}\\n     get [id, name] = cast\\n     cpy id = id\\n     let priority = (get_skill_priority id)\\n     let append = {cont} {k} (Cons [id, name] (cont k))\\n     (update6 priority append arr)\\n   dup rec = (casts #loop)\\n   dup arr = # (rec arr)\\n   dup fold = (fold6 #{arr1 arr2} {Nil} (arr1 (arr2 Nil)) #{x} x)\\n   #(fold arr)\\n\\n  let cast = {cast board}\\n    get [skill, argm]  = cast\\n    cpy skill          = skill\\n    let hero           = |skill / 4|\\n    get [board, cpos]  = (get_hero_position hero board) \\n    let case_cpos_none = {board}\\n      board\\n    let case_cpos_just = {cpos} {board}\\n      get [cpos0, cpos1] = (vec2_cpy cpos)\\n      get [board, unit]  = (get_at cpos0 board)\\n      let is_muted       = (get_unit_mute unit)\\n      (if is_muted\\n        then: {cpos board} board\\n        else: {cpos board}\\n          let effect = (get_skill_effect skill)\\n          let board  = (effect cpos argm board)\\n          board\\n      cpos1 board)\\n    (cpos case_cpos_none case_cpos_just board)\\n\\n  let test_muted_cast =\\n      let board = new_board\\n      let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n      let board = (cast [SILENCE,[0xc,0x0]] board)\\n      let board = (board_update [0xd,0x1] (dmge 8) board)\\n      let board = (cast [RESTORE,[0xd,0x1]] board)\\n      (print_board board)\\n\\n  // TODO: create end_turn function\\n  dup end_turn = \\n    let fold_node = {lft rgt}\\n      [lft, rgt]\\n    let fold_leaf = {unit}\\n      cpy unit = unit\\n      let case_void =\\n        unit\\n      let case_item =\\n        cpy item = (get_unit_type unit)\\n        if |item == ROCK| then:\\n          Void\\n        else: if |item == TRAP| then:\\n          Void\\n        else:\\n          unit\\n      let case_goal =\\n        unit\\n      let case_hero =\\n        cpy lock = (get_unit_lock unit)\\n        cpy mute = (get_unit_mute unit)\\n        cpy hero = (get_unit_hero unit)\\n        cpy spec = (get_unit_spec unit)\\n        let lock = if |lock > 0| [|lock - 1|, lock]\\n        let mute = if |mute > 0| [|mute - 1|, mute]\\n        let defs = 0\\n        let spec = if ||hero == KENLUA| & |spec > 0|| [0, spec] // remove DODGE\\n        let spec = if ||hero == CRONI| & |spec > 0|| [0, spec] // remove SHADOW_BOND\\n        let unit = (set_unit_lock lock unit)\\n        let unit = (set_unit_mute mute unit)\\n        let unit = (set_unit_defs defs unit)\\n        let unit = (set_unit_spec spec unit)\\n        unit\\n      (match_unit_kind unit case_void case_item case_goal case_hero)\\n    (fold8 #fold_node #fold_leaf)\\n\\n  let test_end_turn =\\n    let board = new_board\\n    let board = (cast [EARTH_WALL,[0xf,0x4]] board)\\n    let board = (cast [SHADOW_BOND,[0xe,0x2]] board)\\n    let board = (board_update [0x0,0xc] (lock 1) board)\\n    let board = (end_turn board)\\n    (print_board board)\\n\\n  dup exports =\\n    [#new_board,\\n    [#cast,\\n    [#print_board,\\n    [#unit_to_scott,\\n    [#get_skill_priority,\\n    [#get_skill_area,\\n    [#get_at,\\n    [#end_turn,\\n    [#TOPHORO,\\n    [#GONK,\\n    [#STANCI,\\n    [#HERO_3,\\n    [#ERKOS,\\n    [#CRONI,\\n    [#SNARCH,\\n    [#HERO_7,\\n    [#SIRPIX,\\n    [#KENLUA,\\n    [#FLINA,\\n    [#HERO_B,\\n    [#ZAGATUR,\\n    [#AGDRIS,\\n    [#MEWEM,\\n    [#HERO_F,\\n     0]]]]]]]]]]]]]]]]]]]]]]]]\\n\\n  # exports\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/kaelin.fmc?");

/***/ }),

/***/ "./formality/stdlib/list.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/list.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Scott-encoded functions\\n\\ndef Cons: {x xs}\\n  {Cons Nil} (Cons x xs)\\n\\ndef Nil:\\n  {Cons Nil} Nil\\n\\ndef head: {default list}\\n  let case_cons = {x rest} x\\n  let case_nil  = default\\n  (list case_cons case_nil)\\n\\ndef tail: {list}\\n  let case_cons = {x rest} rest\\n  let case_nil  = Nil\\n  (list case_cons case_nil)\\n\\ndef pop: {default list}\\n  let case_cons = {x rest} [rest, x]\\n  let case_nil  = [Nil, default]\\n  (list case_cons case_nil)\\n\\n// Church-encoded functions\\n\\ndef ConsF: {x xs}\\n  {Cons}\\n  dup x    = x\\n  dup Cons = Cons\\n  dup func = (xs #Cons)\\n  # {nil} (Cons x (func nil))\\n\\ndef NilF:\\n  {Cons}\\n  # {nil} nil\\n\\ndef list_unfold: {list}\\n  dup F = (list #Cons)\\n  # (F nil)\\n\\ndef build: {len init loop} {cons}\\n  dup loop = loop\\n  dup init = init\\n  dup cons = cons\\n  dup fold = (len #{list state}\\n    get [state, element] = (loop state)\\n    (cons element (list state)))\\n  # {nil} (fold {state}nil init)\\n\\n// Concatenates two lists\\ndef concat: {a b}\\n  {Cons}\\n  dup Cons = Cons\\n  dup append-a = (a #Cons)\\n  dup append-b = (b #Cons)\\n  # {nil} (append-a (append-b nil))\\n\\n// Converts Scott to Church in O(len).\\ndef list_fold_f: {len Cons}\\n  dup Cons = Cons\\n  let func = {cont list}\\n    let case_cons = {head tail nil} (Cons head (cont tail nil))\\n    let case_nil  = {nil} nil\\n    (list case_cons case_nil)\\n  dup fold = (len #func)\\n  # {nil list} (fold {tail}{nil}nil list nil)\\n\\n// Non-fused version of the function above.\\ndef list_fold: {len}\\n  dup fold_f = (list_fold_f len #ConsF)\\n  # {list} (fold_f NilF list)\\n\\ndef map: {as f Cons}\\n  dup f = f\\n  dup Cons = Cons\\n  let case_cons = {a} (Cons (f a))\\n  dup A = (as #case_cons)\\n  # {Nil} (A Nil)\\n\\n// reverse tail call and fusionable\\ndef reverse:\\n  {as}\\n  let iterate = {xs ys Cons}\\n    dup Cons = Cons\\n    dup rec = (xs #{x h p} (h (Cons x p)))\\n    dup p = (ys #Cons)\\n    #{N} (rec {p} p (p N))\\n  (iterate as NilF)\\n\\ndef filter:\\n// {:(List !A)} {:!{:!A} Bool} !(List !A)\\n  {xs p}\\n  dup p = p\\n  {Cons}\\n  dup Cons = Cons\\n  dup rec = (xs #{x h}\\n    dup x = x\\n    (p #x {r} (Cons #x r) {r} r h))\\n  #{N} (rec N)\\n\\ndef foldl: {as op}\\n  dup op = op\\n  dup rec = (as #{a h} (op h a))\\n  #{b} (rec b)\\n\\ndef foldr: {as op}\\n  dup op = op\\n  dup rec = (as #{a h} (op a h))\\n  # {b} (rec b)\\n\\ndef example_list: (reverse (map (ConsF #3 (ConsF #4 (ConsF #7 (ConsF #2 (ConsF #0 NilF))))) #{x} |x * 2|))\\ndef example_foldr: (foldr example_list #{x y} |x + y|)\\n\\ndef list:\\n  let list = {a} dup a = a # {b} (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 70 (a 32 (a 108 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 83 (a 32 (a 116 (a 32 (a 60 (a 32 (a 62 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 67 (a 32 (a 114 (a 32 (a 91 (a 32 (a 93 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 84 (a 32 (a 111 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 71 (a 32 (a 111 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 91 (a 32 (a 93 (a 32 (a 69 (a 32 (a 114 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 60 (a 32 (a 62 (a 32 (a 83 (a 32 (a 116 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 77 (a 32 (a 101 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 32 (a 32 (a 46 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 (a 32 (a 91 (a 32 (a 93 b)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\\n  (from_chars list)\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/list.fmc?");

/***/ }),

/***/ "./formality/stdlib/main.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/main.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def add_test:\\n  |3 + 2|\\n\\ndef mul_test:\\n  |3 * 2|\\n\\ndef tup_test:\\n  (tup_fst (Tup 42 1337))\\n\\ndef pair_test:\\n  fst [42 , 1337]\\n\\ndef list_test:\\n  (Cons #1 (Cons #2 (Cons #3 Nil)))\\n\\ndef list_fold_test:\\n  dup fold = (list_fold ~3)\\n  # (fold list_test)\\n\\ndef list_fold_f_test:\\n  {Cons}\\n  dup fold_f = (list_fold_f ~3 Cons)\\n  # {Nil} (fold_f Nil list_test)\\n\\ndef if_test:\\n  if 1\\n  then: \\\"cond is true\\\"\\n  else: \\\"cond is false\\\"\\n\\ndef cpy_test:\\n  cpy num = 42\\n  [[num, num], |num + num|]\\n\\ndef prj_test:\\n  get [fst, snd] = [42, 1337]\\n  (tup fst snd)\\n\\ndef fib_test:\\n  (fib ~65536)\\n\\ndef to_chars_test:\\n  (to_chars \\\"abcdefgh\\\")\\n\\ndef string_concat_test:\\n  (string_concat \\\"Hello, \\\" \\\"world!\\\")\\n\\ndef sum_test:\\n  let upto = ~100000\\n  let init =\\n    [0, 0]\\n  let loop = {state}\\n    get [idx, sum] = state\\n    cpy idx        = idx\\n    [|idx + 1|, |sum + idx|]\\n  let done = {state} snd state\\n  (for upto #init #loop #done)\\n\\ndef term_test:\\n  term_example\\n\\ndef array_test:\\n  array_example\\n\\ndef main:\\n  string_concat_test\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/main.fmc?");

/***/ }),

/***/ "./formality/stdlib/maybe.fmc":
/*!************************************!*\
  !*** ./formality/stdlib/maybe.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def None:\\n  {None Just}\\n  None\\n\\ndef Just: {val}\\n  {None Just}\\n  (Just val)\\n\\ndef maybe_concat: {a b}\\n  (a b Just)\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/maybe.fmc?");

/***/ }),

/***/ "./formality/stdlib/nat.fmc":
/*!**********************************!*\
  !*** ./formality/stdlib/nat.fmc ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// :::::::::\\n// :: Nat ::\\n// :::::::::\\n\\n// Church-encoded Nats are used to perform bounded loops and recursion.\\n// See the examples on the end of the file to see how they work!\\n\\ndef Zero:\\n  {Succ Zero}\\n  Zero\\n\\ndef Succ: {pred}\\n  {Succ Zero}\\n  (Succ pred)\\n\\ndef ZeroF:\\n  {s}\\n  # {z} z\\n\\ndef SuccF: {n}\\n  {s}\\n  dup s = s\\n  dup f = (n #s)\\n  # {z} (s (f z))\\n\\ndef mul: {a b}\\n  {s} \\n  dup S = s\\n  dup A =\\n    dup B = (b #S)\\n    (a #B)\\n  # {z} (A z)\\n\\n// Bounded for-loop\\ndef for: {numb init loop stop}\\n  dup init = init\\n  dup exec = (numb loop)\\n  dup stop = stop\\n  # (stop (exec init))\\n\\ndef nat_to_chars: {nat}\\n  let init = (to_chars \\\"Z\\\")\\n  let loop = {chars} (concat (to_chars \\\"S\\\") chars)\\n  let stop = {chars} chars\\n  (for nat #init #loop #stop)\\n\\ndef nat_to_string: {nat}\\n  dup chars = (nat_to_chars nat)\\n  # (from_chars chars) \\n\\ndef nat_unfold: {n}\\n  let init = Zero\\n  let loop = Succ\\n  let stop = {x}x\\n  (for n #init #loop #stop)\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/nat.fmc?");

/***/ }),

/***/ "./formality/stdlib/num.fmc":
/*!**********************************!*\
  !*** ./formality/stdlib/num.fmc ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Gets the nth number of the Fibonacci sequence\\ndef fib: {n}\\n  let init = [0,1]\\n  let loop = {state}\\n    get [a, b] = state\\n    cpy b      = b\\n    [b, |a + b|]\\n  let stop = {state}\\n    (snd state)\\n  (for n #init #loop #stop)\\n\\ndef boxed_add: {x y}\\n  dup x = x\\n  dup y = y\\n  # |x + y|\\n\\ndef num_dif: {a b}\\n  cpy a = a\\n  cpy b = b\\n  if |a > b|\\n  then: |a - b|\\n  else: |b - a|\\n\\ndef num_to_char: {n}\\n  cpy n = n\\n  if |n < 10|\\n  then: |n + 48|\\n  else: |n + 87|\\n\\ndef max: {a b}\\n  cpy a = a\\n  cpy b = b\\n  if |a > b| then:\\n    a\\n  else:\\n    b\\n\\ndef min: {a b}\\n  cpy a = a\\n  cpy b = b\\n  if |a < b| then:\\n    a\\n  else:\\n    b\\n\\n// box_byte\\n// : {n : Num} !Num\\ndef box_byte: {n}\\n  cpy n = n\\n  dup b00 = if ||n >>  0| & 1| [#{x}|x + 0x1|, #{x}x]\\n  dup b01 = if ||n >>  1| & 1| [#{x}|x + 0x2|, #{x}x]\\n  dup b02 = if ||n >>  2| & 1| [#{x}|x + 0x4|, #{x}x]\\n  dup b03 = if ||n >>  3| & 1| [#{x}|x + 0x8|, #{x}x]\\n  dup b04 = if ||n >>  4| & 1| [#{x}|x + 0x10|, #{x}x]\\n  dup b05 = if ||n >>  5| & 1| [#{x}|x + 0x20|, #{x}x]\\n  dup b06 = if ||n >>  6| & 1| [#{x}|x + 0x40|, #{x}x]\\n  dup b07 = if ||n >>  7| & 1| [#{x}|x + 0x80|, #{x}x]\\n  # (b07 (b06 (b05 (b04 (b03 (b02 (b01 (b00 0))))))))\\n\\n// box_num\\n// : {n : Num} !Num\\ndef box_num: {n}\\n  cpy n = n\\n  dup b00 = if ||n >>  0| & 1| [#{x}|x + 0x1|, #{x}x]\\n  dup b01 = if ||n >>  1| & 1| [#{x}|x + 0x2|, #{x}x]\\n  dup b02 = if ||n >>  2| & 1| [#{x}|x + 0x4|, #{x}x]\\n  dup b03 = if ||n >>  3| & 1| [#{x}|x + 0x8|, #{x}x]\\n  dup b04 = if ||n >>  4| & 1| [#{x}|x + 0x10|, #{x}x]\\n  dup b05 = if ||n >>  5| & 1| [#{x}|x + 0x20|, #{x}x]\\n  dup b06 = if ||n >>  6| & 1| [#{x}|x + 0x40|, #{x}x]\\n  dup b07 = if ||n >>  7| & 1| [#{x}|x + 0x80|, #{x}x]\\n  dup b08 = if ||n >>  8| & 1| [#{x}|x + 0x100|, #{x}x]\\n  dup b09 = if ||n >>  9| & 1| [#{x}|x + 0x200|, #{x}x]\\n  dup b10 = if ||n >> 10| & 1| [#{x}|x + 0x400|, #{x}x]\\n  dup b11 = if ||n >> 11| & 1| [#{x}|x + 0x800|, #{x}x]\\n  dup b12 = if ||n >> 12| & 1| [#{x}|x + 0x1000|, #{x}x]\\n  dup b13 = if ||n >> 13| & 1| [#{x}|x + 0x2000|, #{x}x]\\n  dup b14 = if ||n >> 14| & 1| [#{x}|x + 0x4000|, #{x}x]\\n  dup b15 = if ||n >> 15| & 1| [#{x}|x + 0x8000|, #{x}x]\\n  dup b16 = if ||n >> 16| & 1| [#{x}|x + 0x10000|, #{x}x]\\n  dup b17 = if ||n >> 17| & 1| [#{x}|x + 0x20000|, #{x}x]\\n  dup b18 = if ||n >> 18| & 1| [#{x}|x + 0x40000|, #{x}x]\\n  dup b19 = if ||n >> 19| & 1| [#{x}|x + 0x80000|, #{x}x]\\n  dup b20 = if ||n >> 20| & 1| [#{x}|x + 0x100000|, #{x}x]\\n  dup b21 = if ||n >> 21| & 1| [#{x}|x + 0x200000|, #{x}x]\\n  dup b22 = if ||n >> 22| & 1| [#{x}|x + 0x400000|, #{x}x]\\n  dup b23 = if ||n >> 23| & 1| [#{x}|x + 0x800000|, #{x}x]\\n  dup b24 = if ||n >> 24| & 1| [#{x}|x + 0x1000000|, #{x}x]\\n  dup b25 = if ||n >> 25| & 1| [#{x}|x + 0x2000000|, #{x}x]\\n  dup b26 = if ||n >> 26| & 1| [#{x}|x + 0x4000000|, #{x}x]\\n  dup b27 = if ||n >> 27| & 1| [#{x}|x + 0x8000000|, #{x}x]\\n  dup b28 = if ||n >> 28| & 1| [#{x}|x + 0x10000000|, #{x}x]\\n  dup b29 = if ||n >> 29| & 1| [#{x}|x + 0x20000000|, #{x}x]\\n  dup b30 = if ||n >> 30| & 1| [#{x}|x + 0x40000000|, #{x}x]\\n  dup b31 = if ||n >> 31| & 1| [#{x}|x + 0x80000000|, #{x}x]\\n  # (b31 (b30 (b29 (b28 (b27 (b26 (b25 (b24\\n    (b23 (b22 (b21 (b20 (b19 (b18 (b17 (b16\\n    (b15 (b14 (b13 (b12 (b11 (b10 (b09 (b08\\n    (b07 (b06 (b05 (b04 (b03 (b02 (b01 (b00\\n      0))))))))))))))))))))))))))))))))\\n\\ndef num_from_nat: {n}\\n  dup fold = (n #{x}|x + 1|)\\n  # (fold 0)\\n\\ndef sqrt: {n}\\n  |n ^^ 2147483648|\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/num.fmc?");

/***/ }),

/***/ "./formality/stdlib/pair.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/pair.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def Pair: {a b}\\n  [a, b]\\n\\ndef pair_fst: {pair}\\n  fst pair\\n\\ndef pair_snd: {pair}\\n  snd pair\\n\\ndef pair_prj: {pair func}\\n  get [val0, val1] = pair\\n  (func val0 val1)\\n\\ndef swap: {pair}\\n  get [a, b] = pair\\n  [b, a]\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/pair.fmc?");

/***/ }),

/***/ "./formality/stdlib/string.fmc":
/*!*************************************!*\
  !*** ./formality/stdlib/string.fmc ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def TEXT: 1954047348\\n\\n// Converts an UTF-8 string into a list of bytes\\ndef to_chars: {str}\\n  {Cons}\\n  dup Cons = Cons\\n  let Cons-non-0 = {c}\\n    cpy c = c\\n    if |c > 0|\\n    then: (Cons c)\\n    else: {x} x\\n  dup f =\\n    let func = {c cs}\\n      cpy c = c\\n      let Cons-c0 = (Cons-non-0 ||c >>  0| & 0xFF|)\\n      let Cons-c1 = (Cons-non-0 ||c >>  8| & 0xFF|)\\n      let Cons-c2 = (Cons-non-0 ||c >> 16| & 0xFF|)\\n      let Cons-c3 = (Cons-non-0 ||c >> 24| & 0xFF|)\\n      (Cons-c0 (Cons-c1 (Cons-c2 (Cons-c3 cs))))\\n    (snd str #func)\\n  # {nil} (f nil)\\n\\n// Converts a list of bytes back to an UTF-8 string\\ndef from_chars: {chars}\\n  let nums =\\n    {Cons}\\n    dup Cons = Cons\\n    dup func =\\n      let loop = {c cont char indx}\\n        cpy indx = indx\\n        cpy char = ||char >> 8| | |c << 24||\\n        cpy done = ||indx % 4| == 3|\\n        let Cons-char =\\n          if done\\n          then: (Cons char)\\n          else: {x}x\\n        let next-char =\\n          if done\\n          then: 0\\n          else: char\\n        (Cons-char (cont next-char |indx + 1|))\\n      (chars #loop)\\n    # {nil} (func {char indx}(Cons char nil) 0 0)\\n  [TEXT, nums]\\n\\ndef string_concat: {a b}\\n  (from_chars (concat (to_chars a) (to_chars b)))\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/string.fmc?");

/***/ }),

/***/ "./formality/stdlib/term.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/term.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Formality implementation in Formality-Core (ongoing work)\\n\\n// Example usage of this library\\n\\ndef term_example:\\n  dup true_t    = #(Lam {t} (Lam {f} t))\\n  dup false_t   = #(Lam {t} (Lam {f} f))\\n  dup not_t     = #(Lam {b} (App (App b false_t) true_t))\\n  dup main_t    = #(App not_t (App not_t (App not_t true_t)))\\n  dup reduce    = (reduce ~256)\\n  dup to_string = (to_string ~256)\\n  # [\\n    [\\\"term:\\\", (to_string main_t)],\\n    [\\\"norm:\\\", (to_string (reduce (main_t)))]]\\n\\n// Scott-encoded functions\\n\\ndef Lam: {body}\\n  {Lam App Var}\\n  (Lam body)\\n\\ndef App: {func argm}\\n  {Lam App Var}\\n  (App func argm)\\n\\ndef Var: {indx}\\n  {Lam App Var}\\n  (Var indx)\\n\\n// Church-encoded functions\\n\\ndef LamF: {body}\\n  {Lam App Var}\\n  dup Lam  = Lam\\n  dup App  = App\\n  dup Var  = Var\\n  dup body = (body #Lam #App #Var)\\n  # (Lam body)\\n\\ndef AppF: {func argm}\\n  {Lam App Var}\\n  dup Lam  = Lam\\n  dup App  = App\\n  dup Var  = Var\\n  dup func = (func #Lam #App #Var)\\n  dup argm = (argm #Lam #App #Var)\\n  # (App func argm)\\n\\ndef VarF: {indx}\\n  {Lam App Var}\\n  dup Lam  = Lam\\n  dup App  = App\\n  dup Var  = Var\\n  dup indx = indx\\n  # (Var indx)\\n\\n// This is how we convert from Scott to Church in O(len).\\ndef term_fold_f: {len Lam App Var}\\n  dup Lam = Lam\\n  dup App = App\\n  dup Var = Var\\n  let func = {cont term}\\n    let case_lam = {body cont}\\n      get [cont, body] = (cont body)\\n      [cont, (Lam body)]\\n    let case_app = {func argm cont}\\n      get [cont, func] = (cont func)\\n      get [cont, argm] = (cont argm)\\n      [cont, (App func argm)]\\n    let case_var = {indx cont}\\n      [cont, (Var indx)]\\n    (term case_lam case_app case_var cont)\\n  dup fold = (len #func)\\n  # {term} (snd (fold {term}[{x}x,term] term))\\n\\n// Non-fused version of the function above.\\ndef term_fold: {len}\\n  dup fold_f = (term_fold_f len #LamF #AppF #VarF)\\n  # {term} (fold_f term_test)\\n\\ndef term_to_string: {len}\\n  let case_lam = {body}\\n    (concat (to_chars \\\"λ\\\") body)\\n  let case_app = {func argm}\\n    (concat (to_chars \\\"(\\\")\\n    (concat func\\n    (concat (to_chars \\\" \\\")\\n    (concat argm (to_chars \\\")\\\")))))\\n  let case_var = {indx}\\n    (to_chars (nat_to_string indx))\\n  dup fold_f = (term_fold_f len #case_lam #case_app #case_var)\\n  # {term} (from_chars (fold_f term))\\n  \\ndef reduce: {len}\\n  let func = {cont term}\\n    let lam_case = {body cont}\\n      [cont, (Lam body)]\\n    let app_case = {func argm cont}\\n      let lam_case = {fbody argm cont} \\n        get [cont, term] = (cont (fbody argm))\\n        [cont, term]\\n      let app_case = {ffunc fargm argm cont}\\n        get [cont, argm] = (cont argm)\\n        [cont, (App (App ffunc fargm) argm)]\\n      let var_case = {findx argm cont}\\n        [cont, findx]\\n      get [cont, func] = (cont func)\\n      (func lam_case app_case var_case argm cont)\\n    let var_case = {indx cont}\\n      [cont, (Var indx)]\\n    (term lam_case app_case var_case cont)\\n  dup fold = (len #func)\\n  # {term} (snd (fold {term}[{x}x,term] term))\\n\\ndef to_string: {len}\\n  let TERM_TO_CHARS = {a b}a\\n  let NUMB_TO_CHARS = {a b}b\\n  let init = {term} [{x}x, term]\\n  let loop = {call name}\\n    let term_to_chars = {call term dept}\\n      let lam_case = {body call dept}\\n        cpy dept         = dept\\n        get [call, body] = (call TERM_TO_CHARS (body (Var dept)) |dept + 1|)\\n        [call, (concat (to_chars \\\"λ\\\") body)]\\n      let app_case = {func argm call dept}\\n        cpy dept         = dept\\n        get [call, func] = (call TERM_TO_CHARS func dept)\\n        get [call, argm] = (call TERM_TO_CHARS argm dept)\\n        [call, (concat (to_chars \\\"(\\\") (concat func (concat (to_chars \\\" \\\") (concat argm (to_chars (\\\")\\\"))))))]\\n      let var_case = {indx call dept}\\n        get [call, indx] = (call NUMB_TO_CHARS indx)\\n        [call, indx]\\n      (term lam_case app_case var_case call dept)\\n    let numb_to_chars = {call num}\\n      let succ_case = {pred call}\\n        get [call, pred] = (call NUMB_TO_CHARS pred)\\n        [call, (concat (to_chars \\\"S\\\") pred)]\\n      let zero_case = {call}\\n        [call, (to_chars \\\"Z\\\")]\\n      cpy num = num\\n      (if |num > 0| [(succ_case |num - 1|),zero_case] call)\\n    (name term_to_chars numb_to_chars call)\\n  let stop = {call term}\\n    get [call, chrs] = (call TERM_TO_CHARS term 0)\\n    (from_chars chrs)\\n  (for len #init #loop #stop)\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/term.fmc?");

/***/ }),

/***/ "./formality/stdlib/tree.fmc":
/*!***********************************!*\
  !*** ./formality/stdlib/tree.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def NodeF: {lft rgt}\\n  {Node Leaf}\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  dup lft  = (lft #Node #Leaf)\\n  dup rgt  = (rgt #Node #Leaf)\\n  # (Node lft rgt)\\n\\ndef LeafF: {val}\\n  {Node Leaf}\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  dup val  = val\\n  # (Leaf val)\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/tree.fmc?");

/***/ }),

/***/ "./formality/stdlib/tuple.fmc":
/*!************************************!*\
  !*** ./formality/stdlib/tuple.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def Tup: {a b}\\n  {tup} (tup a b)\\n\\ndef tup_fst: {tup}\\n  (tup {a b}a)\\n\\ndef tup_snd: {tup}\\n  (tup {a b}b)\\n\\ndef pushfront: {a tup} {t} (tup (t a))\\ndef pushback: {a tup} {t} (tup t a)\\ndef popfront: {tup} {t} (tup {-} t)\\n\\ndef empty_tup: {t} t\\n\\ndef concat_tup: {tup1 tup2} {t}\\n  (tup2 (tup1 t))\\n\\ndef example_tup: (concat_tup (pushfront 0 (pushback 4 (pushback 3 (pushfront 1 (pushfront 2 empty_tup))))) (pushfront 5 empty_tup))\\n\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/tuple.fmc?");

/***/ }),

/***/ "./formality/stdlib/vector2.fmc":
/*!**************************************!*\
  !*** ./formality/stdlib/vector2.fmc ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// ::::::::::\\n// :: Vec2 ::\\n// ::::::::::\\n\\n// vec2_add\\n// | Receives two 2D vectors and adds them\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   [Num,Num]\\ndef vec2_add: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  [|ax + bx|, |ay + by|]\\n\\n// vec2_scale\\ndef vec2_scale: {a s}\\n  get [ax,ay] = a\\n  [|ax * s|, |ay * s|]\\n\\n// vec2_neg\\n// | Negates a 2D vector\\n// : {a : [Num,Num]}\\n//   [Num,Num]\\ndef vec2_neg: {a}\\n  get [ax,ay] = a\\n  [|0 - ax|, |0 - ay|]\\n\\n// vec2_cpy\\n// | Copies a 2D vector\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   [[Num,Num], [Num,Num]]\\ndef vec2_cpy: {a}\\n  get [ax,ay] = a\\n  cpy ax      = ax\\n  cpy ay      = ay\\n  [[ax,ay], [ax,ay]]\\n\\n// vec2_sqr_dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef vec2_sqr_dist: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  cpy dx = |(num_dif ax bx) ** 2|\\n  cpy dy = |(num_dif ay by) ** 2|\\n  |dx + dy|\\n\\n// vec2_dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef vec2_dist: {a b}\\n  (sqrt (vec2_sqr_dist a b))\\n\\n// vec2_flat_dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef vec2_flat_dist: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  |(num_dif ax bx) + (num_dif ay by)|\\n\\n// vec2_line\\n// | Up to `max_len`, given a length `len`, a center pos `pos`, and a displacement\\n// | vector `dxy`, returns vectors from `pos`, incrementing by `dxy`, `len` times.\\n// : {max_len : Nat}\\n//   {-P      : Type}\\n//   {cons    : ! {x : [Num,Num]} {xs : P} P}\\n// ! {len     : Num}\\n//   {pos     : [Num,Num]}\\n//   {dxy     : [Num,Num]}\\n//   {nil     : P}\\n//   P\\ndef vec2_line: {max_len} {cons}\\n  dup cons = cons\\n  dup fold = (max_len #{list len pos dxy}\\n    get [ax,ay] = pos\\n    get [dx,dy] = dxy\\n    cpy len = len\\n    cpy ax  = ax\\n    cpy ay  = ay\\n    cpy dx  = dx\\n    cpy dy  = dy\\n    (if |len == 0|\\n      then: {list} (list 0 [0,0] [0,0])\\n      else: {list} (cons [ax,ay] (list |len - 1| [|ax + dx|,|ay + dy|] [dx,dy]))\\n      list))\\n  # {len pos dxy nil}\\n    (fold {len pos dxy}nil len pos dxy)\\n\\n// vec2_area\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {size : [Num,Num]}\\n//   {cond : ! {x : [Num,Num]} Num}\\n//   {cons : ! {x : [Num,Num]} {xs : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {siz  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef vec2_area: {mlen size cond} {cons}\\n  dup cons = cons\\n  dup size = size\\n  dup cond = cond\\n  dup fold = (mlen #{list pos idx}\\n    get [cx,cy] = pos\\n    get [sx,sy] = size\\n    cpy sx = sx\\n    cpy sy = sy\\n    cpy cx = cx\\n    cpy cy = cy\\n    cpy ix = idx\\n    cpy px = ||cx + |ix % sx|| - |sx / 2||\\n    cpy py = ||cy + |ix / sx|| - |sy / 2||\\n    let fn = (if (cond [cx,cy] [sx,sy] [px,py]) [(cons [px,py]),{x}x])\\n    let xs = (list [cx,cy] |ix + 1|)\\n    (fn xs))\\n  # {pos nil}\\n    (fold {pos idx}nil pos 0)\\n\\n// vec2_rect\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {size : [Num,Num]}\\n//   {cons : ! {x : [Num,Num]} {xs : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {siz  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef vec2_rect: {mlen size}\\n  (vec2_area mlen size #{cen siz pos}1)\\n\\ndef vec2_rect_example: {cons}\\n  dup cons = cons\\n  dup area = (vec2_rect ~16 #[4,4] #cons)\\n  # (area [100,100])\\n\\n//vec2_circle\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {srad : Num} -- squared radius\\n//   {cons : ! {pos : [Num,Num]} {state : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef vec2_circle: {mlen srad cons}\\n  dup cons = cons\\n  dup srad = srad\\n  let isin = {cen siz pos} |(vec2_sqr_dist cen pos) < srad|\\n  dup size = #||(sqrt srad) * 2| + 1|\\n  dup area = (vec2_area mlen #[size,size] #isin #cons)\\n  # {pos} (area pos)\\n\\n// . . .\\n// . x .\\n// . . .\\ndef vec2_circle_a: (vec2_circle ~1 #1)\\n\\n// . . . . .\\n// . . x . .\\n// . x x x .\\n// . . x . .\\n// . . . . .\\ndef vec2_circle_b: (vec2_circle ~9 #2)\\n\\n// . . . . .\\n// . x x x .\\n// . x x x .\\n// . x x x .\\n// . . . . .\\ndef vec2_circle_c: (vec2_circle ~9 #3)\\n\\n// . . . . . . .\\n// . . . x . . .\\n// . . x x x . .\\n// . x x x x x .\\n// . . x x x . .\\n// . . . x . . .\\n// . . . . . . .\\ndef vec2_circle_d: (vec2_circle ~25 #5)\\n\\n// . . . . . . .\\n// . . x x x . .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . . x x x . .\\n// . . . . . . .\\ndef vec2_circle_e: (vec2_circle ~25 #6)\\n\\n// . . . . . . .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . . . . . . .\\ndef vec2_circle_f: (vec2_circle ~25 #9)\\n\\n// . . . . . . . . .\\n// . . . . x . . . .\\n// . . x x x x x . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . x x x x x . .\\n// . . . . x . . . .\\n// . . . . . . . . .\\ndef vec2_circle_g: (vec2_circle ~49 #10)\\n\\n// . . . . . . . . .\\n// . . . x x x . . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . . x x x . . .\\n// . . . . . . . . .\\ndef vec2_circle_h: (vec2_circle ~49 #11)\\n\\n// . . . . . . . . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . . . . . . . .\\ndef vec2_circle_i: (vec2_circle ~49 #14)\\n\\n// . . . . . . . . . . .\\n// . . . . . x . . . . .\\n// . . . x x x x x . . .\\n// . . x x x x x x x . .\\n// . . x x x x x x x . .\\n// . x x x x x x x x x .\\n// . . x x x x x x x . .\\n// . . x x x x x x x . .\\n// . . . x x x x x . . .\\n// . . . . . x . . . . .\\n// . . . . . . . . . . .\\ndef vec2_circle_j: (vec2_circle ~81 #17)\\n\\n// Approximates the area of a circle (2*pi*r)\\ndef vec2_circle_example: \\n  let radi = 9\\n  let form = (vec2_circle ~2048 #||radi * radi| + 1|)\\n  let hits = {pos num} |num + 1|\\n  dup circ = (form #hits)\\n  # (circ [0,0] 0)\\n\\n//vec2_range\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {rad  : Num} -- radius\\n//   {cons : ! {pos : [Num,Num]} {state : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef vec2_range: {mlen rad cons}\\n  dup cons = cons\\n  dup rad  = rad\\n  let isin = {cen siz pos} |(vec2_flat_dist cen pos) < |rad + 1||\\n  dup size = # ||rad * 2| + 1|\\n  dup area = (vec2_area mlen #[size,size] #isin #cons)\\n  # {pos} (area pos)\\n\\ndef vec2_range_0: (vec2_range ~1 #0)\\ndef vec2_range_1: (vec2_range ~9 #1)\\ndef vec2_range_2: (vec2_range ~25 #2)\\ndef vec2_range_3: (vec2_range ~49 #3)\\ndef vec2_range_4: (vec2_range ~81 #4)\\ndef vec2_range_5: (vec2_range ~121 #5)\\ndef vec2_range_6: (vec2_range ~169 #6)\\n\\n// vec2_wave\\n// | Given a list of widths, returns vectors filling a wave from `pos` pointing to `dir`.\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos : [Num,Num]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef vec2_wave: {widths} {cons}\\n  dup cons = cons\\n  dup line = (vec2_line ~7 #cons)\\n  dup fold = (widths #{w ws pos dxy}\\n    get [ax,ay] = pos\\n    get [dx,dy] = dxy\\n    cpy w  = w\\n    cpy ax = ax\\n    cpy ay = ay\\n    cpy dx = dx\\n    cpy dy = dy\\n    cpy nx = dy\\n    cpy ny = |0 - dx|\\n    let ix = |ax - |nx * |w / 2||| \\n    let iy = |ay - |ny * |w / 2|||\\n    let t  = (ws [|ax + dx|,|ay + dy|] [dx,dy])\\n    (line w [ix,iy] [nx,ny] t))\\n  # {pos dxy nil}\\n    (fold {pos dxy}nil pos dxy)\\n\\n// vec2_wave_out\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos_dir : [[Num,Num],[Num,Num]]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef vec2_wave_out: {widths} {cons} \\n  dup cons = cons\\n  dup wave = (vec2_wave widths #{pos rest dxy}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (cons [pos,dxy0] (rest dxy1)))\\n  # {pos dxy nil}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (wave pos dxy0 {dxy}nil dxy1)\\n\\n// vec2_wave_in\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos_dir : [[Num,Num],[Num,Num]]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef vec2_wave_in: {widths} {cons} \\n  dup cons = cons\\n  dup wave = (vec2_wave widths #{pos rest res dxy}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (rest (cons [pos,dxy0] res) dxy1))\\n  # {pos dxy nil}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (wave pos dxy0 {res dxy}res nil (vec2_neg dxy1))\\n\");\n\n//# sourceURL=webpack:///./formality/stdlib/vector2.fmc?");

/***/ }),

/***/ "./node_modules/formality-core/exports.js":
/*!************************************************!*\
  !*** ./node_modules/formality-core/exports.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var fm = module.exports = {\n  core: __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\"),\n  net: __webpack_require__(/*! formality-net */ \"./node_modules/formality-net/fm-net.js\"),\n  to_net: __webpack_require__(/*! ./fm-to-net.js */ \"./node_modules/formality-core/fm-to-net.js\"),\n  to_js: __webpack_require__(/*! ./fm-to-js.js */ \"./node_modules/formality-core/fm-to-js.js\"),\n  norm, check, exec\n};\n\nfunction norm(term, defs, mode = \"OPTIMAL_LAZY\", stats = {}) {\n  switch (mode) {\n    case \"BOXED\":\n      return fm.core.norm(term, defs, false);\n    case \"UNBOXED\":\n      return fm.core.norm(term, defs, true);\n    case \"NATIVE\":\n      return fm.to_js.decompile(fm.to_js.compile(term, defs));\n    case \"OPTIMAL_STRICT\":\n    case \"OPTIMAL_LAZY\":\n      var net = fm.to_net.compile(term, defs);\n      if (stats && stats.input_net === null) {\n        stats.input_net = JSON.parse(JSON.stringify(net));\n      }\n      if (mode === \"OPTIMAL_LAZY\") {\n        var new_stats = net.reduce_lazy(stats || {});\n      } else {\n        var new_stats = net.reduce_strict(stats || {});\n      }\n      if (stats && stats.output_net !== undefined) {\n        stats.output_net = JSON.parse(JSON.stringify(net));\n      }\n      return fm.to_net.decompile(net);\n  }\n}\n\nfunction exec(name, defs, infs, mode = \"OPTIMAL_LAZY\", bipass = false, stats = {}) {\n  if (defs[name] && defs[name][0] === \"Ref\" && !defs[defs[name][1].name]) {\n    name = defs[name][1].name;\n  }\n  if (defs[name]) {\n    return fm.norm(check(defs[name], defs, bipass), defs, mode, stats);\n  } else if (infs[name]) {\n    var data = infs[name];\n    var init = check(data.init, defs, bipass);\n    var step = check(data.step, defs, bipass);\n    var stop = check(data.stop, defs, bipass);\n    var done = check(data.done, defs, bipass);\n    var term = fm.core.norm(init, mode, stats);\n    var cont = term => {\n      var res = fm.norm(fm.core.App(stop, term), defs, mode, stats);\n      if (res[0] === \"Put\") {\n        res = res[1].expr;\n      }\n      return res[0] === \"Num\" && res[1].numb === 0;\n    }\n    while (cont(term)) {\n      term = fm.norm(fm.core.App(step, term), defs, mode, stats);\n      stats.loops += 1;\n    }\n    term = fm.norm(fm.core.App(done, term), defs, mode, stats);\n    return term;\n  } else {\n    throw \"Definition '\" + name + \"' not found.\";\n  }\n}\n\nfunction check(term, defs, bipass = false) {\n  if (!bipass) {\n    try {\n      fm.core.check(term, defs);\n      return term;\n    } catch (e) {\n      console.log(e.toString());\n      process.exit();\n    }\n  } else {\n    return term;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/formality-core/exports.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-core.js":
/*!************************************************!*\
  !*** ./node_modules/formality-core/fm-core.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Core Language ~~\n\n// ::::::::::\n// :: Term ::\n// ::::::::::\n\n// An ESCoC term is an ADT represented by a JSON\nconst Var = (index)                  => [\"Var\", {index}];\nconst Lam = (name, body)             => [\"Lam\", {name, body}];\nconst App = (func, argm)             => [\"App\", {func, argm}];\nconst Put = (expr)                   => [\"Put\", {expr}];\nconst Dup = (name, expr, body)       => [\"Dup\", {name, expr, body}];\nconst Num = (numb)                   => [\"Num\", {numb}];\nconst Op1 = (func, num0, num1)       => [\"Op1\", {func, num0, num1}];\nconst Op2 = (func, num0, num1)       => [\"Op2\", {func, num0, num1}];\nconst Ite = (cond, pair)             => [\"Ite\", {cond, pair}];\nconst Cpy = (name, numb, body)       => [\"Cpy\", {name, numb, body}];\nconst Par = (val0, val1)             => [\"Par\", {val0, val1}];\nconst Fst = (pair)                   => [\"Fst\", {pair}];\nconst Snd = (pair)                   => [\"Snd\", {pair}];\nconst Prj = (nam0, nam1, pair, body) => [\"Prj\", {nam0, nam1, pair, body}];\nconst Ref = (name)                   => [\"Ref\", {name}];\n\n// :::::::::::::\n// :: Parsing ::\n// :::::::::::::\n\n// Converts a string to a term\nconst parse = (code) => {\n  function is_space(char) {\n    return char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\n  }\n\n  function is_newline(char) {\n    return char === \"\\n\";\n  }\n\n  function is_name_char(char) {\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-\".indexOf(char) !== -1;\n  }\n\n  function next() {\n    if (is_newline(code[idx])) {\n      row += 1;\n      col = 0;\n    } else {\n      col += 1;\n    }\n    idx += 1;\n  }\n\n  function skip_spaces() {\n    while (idx < code.length && is_space(code[idx])) {\n      next();\n    }\n  }\n\n  function next_char() {\n    skip_spaces();\n    while (code.slice(idx, idx + 2) === \"//\") {\n      while (code[idx] !== \"\\n\" && idx < code.length) {\n        next();\n      }\n      skip_spaces();\n    }\n  }\n\n  function match(string) {\n    next_char();\n    var sliced = code.slice(idx, idx + string.length);\n    if (sliced === string) {\n      for (var i = 0; i < string.length; ++i) {\n        next();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function parse_exact(string) {\n    if (!match(string)) {\n      var text = \"\";\n      var part = \"\";\n      text += \"Parse error: expected '\" + string + \"' \";\n      text += \"on line \" + (row+1) + \", col \" + col + \", but found '\" + code[idx] + \"' instead. Relevant code:\\n\";\n      for (var ini = idx, il = 0; il < 6 && ini >=          0; --ini) if (code[ini] === \"\\n\") ++il;\n      for (var end = idx, el = 0; el < 6 && end < code.length; ++end) if (code[end] === \"\\n\") ++el;\n      part += code.slice(ini+1, idx) + \"<HERE>\" + code.slice(idx, end);\n      text += part.split(\"\\n\").map((line,i) => (\"    \" + (row-il+i+1)).slice(-4) + \"| \" + line).join(\"\\n\");\n      throw text;\n    }\n  }\n\n  function parse_string(fn = is_name_char) {\n    next_char();\n    var name = \"\";\n    while (idx < code.length && fn(code[idx])) {\n      name = name + code[idx];\n      next();\n    }\n    return name;\n  }\n\n  function parse_term(ctx) {\n    // Application\n    if (match(\"(\")) {\n      var term = parse_term(ctx);\n      while (idx < code.length && !match(\")\")) {\n        var argm = parse_term(ctx);\n        var term = App(term, argm);\n        next_char();\n      }\n      return term;\n    }\n\n    // Lambda\n    else if (match(\"{\")) {\n      var names = [];\n      while (idx < code.length && !match(\"}\")) {\n        names.push(parse_string());\n      }\n      var term = parse_term(ctx.concat(names));\n      for (var i = names.length - 1; i >= 0; --i) {\n        term = Lam(names[i], term);\n      }\n      return term;\n    }\n\n    // Duplication\n    else if (match(\"dup \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var expr = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return Dup(name, expr, body);\n    }\n\n    // Put\n    else if (match(\"#\")) {\n      var expr = parse_term(ctx);\n      return Put(expr);\n    }\n\n    // Let\n    else if (match(\"let \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var copy = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return subst(body, copy, 0);\n    }\n\n    // Operation\n    else if (match(\"|\")) {\n      var num0 = parse_term(ctx);\n      var func = parse_string(c => !is_space(c));\n      var num1 = parse_term(ctx);\n      var skip = parse_exact(\"|\");\n      return Op2(func, num0, num1);\n    }\n\n    // String\n    else if (match(\"\\\"\")) {\n      // Parses text\n      var text = \"\";\n      while (code[idx] !== \"\\\"\") {\n        text += code[idx];\n        next();\n      }\n      next();\n      return text_to_term(text);\n    }\n\n    // Nat\n    else if (match(\"~\")) {\n      var name = parse_string();\n      var numb = Number(name);\n      return numb_to_term(numb);\n    }\n\n    // If-Then-Else\n    else if (match(\"if \")) {\n      var cond = parse_term(ctx);\n      var pair = parse_term(ctx);\n      return Ite(cond, pair);\n    }\n\n    // Copy\n    else if (match(\"cpy \")) {\n      var name = parse_string();\n      let skip = parse_exact(\"=\");\n      var numb = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return Cpy(name, numb, body);\n    }\n\n    // Pair\n    else if (match(\"[\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\",\");\n      var val1 = parse_term(ctx);\n      var skip = parse_exact(\"]\");\n      return Par(val0, val1);\n    }\n    \n    // Pair (If-Then-Else sugar)\n    else if (match(\"then:\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\"else:\");\n      var val1 = parse_term(ctx);\n      return Par(val0, val1);\n    }\n\n    // First\n    else if (match(\"fst \")) {\n      var pair = parse_term(ctx);\n      return Fst(pair);\n    }\n\n    // Second\n    else if (match(\"snd \")) {\n      var pair = parse_term(ctx);\n      return Snd(pair);\n    }\n\n    // Projection\n    else if (match(\"get \")) {\n      var skip = parse_exact(\"[\");\n      var nam0 = parse_string();\n      var skip = parse_exact(\",\");\n      var nam1 = parse_string();\n      var skip = parse_exact(\"]\");\n      var skip = parse_exact(\"=\");\n      var pair = parse_term(ctx);\n      var body = parse_term(ctx.concat([nam0, nam1]));\n      return Prj(nam0, nam1, pair, body);\n    }\n\n    // Variable / Reference\n    else {\n      var name = parse_string();\n      var numb = Number(name);\n      if (!isNaN(numb)) {\n        return Num(numb >>> 0);\n      }\n      var skip = 0;\n      while (match(\"'\")) {\n        skip += 1;\n      }\n      for (var i = ctx.length - 1; i >= 0; --i) {\n        if (ctx[i] === name) {\n          if (skip === 0) break;\n          else skip -= 1;\n        }\n      }\n      if (i === -1) {\n        return Ref(name);\n      } else {\n        return Var(ctx.length - i - 1);\n      }\n    }\n  }\n\n  var idx = 0;\n  var row = 0;\n  var col = 0;\n  var defs = {};\n  var infs = {};\n  while (idx < code.length) {\n    next_char();\n    if (match(\"inf \")) {\n      var name = parse_string();\n      var skip = parse_exact(\":\");\n      var skip = parse_exact(\"init:\");\n      var init = parse_term([]);\n      var skip = parse_exact(\"step:\");\n      var step = Lam(\"self\", parse_term([\"self\"]));\n      var skip = parse_exact(\"stop:\");\n      var stop = Lam(\"self\", parse_term([\"self\"]));\n      var skip = parse_exact(\"done:\");\n      var done = Lam(\"self\", parse_term([\"self\"]));\n      infs[name] = {init, step, stop, done};\n    } else {\n      var skip = parse_exact(\"def \");\n      var name = parse_string();\n      var skip = parse_exact(\":\");\n      var term = parse_term([]);\n      defs[name] = term;\n    }\n    next_char();\n  }\n\n  return {defs, infs};\n}\n\n// :::::::::::::::::::::\n// :: Stringification ::\n// :::::::::::::::::::::\n\n// Generates a name\nconst gen_name = (n) => {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\n// Converts a term to a string\nconst show = ([ctor, args], canon = false, ctx = []) => {\n  switch (ctor) {\n    case \"Var\":\n      return ctx[ctx.length - args.index - 1] || \"^\" + args.index;\n    case \"Lam\":\n      var term = [ctor, args];\n      var numb = null;\n      var names = [];\n      while (term[0] === \"Lam\") {\n        numb = term_to_numb(term);\n        if (numb !== null) {\n          break;\n        } else {\n          names.push(canon ? gen_name(ctx.length) : term[1].name);\n          term = term[1].body;\n        }\n      }\n      var head = names.length > 0 ? \"{\" + names.join(\" \") + \"} \" : \"\";\n      if (numb !== null) {\n        return head + \"~\" + Number(numb);\n      } else {\n        return head + show(term, canon, ctx.concat(names))\n      }\n    case \"App\":\n      var text = \")\";\n      var term = [ctor, args];\n      while (term[0] === \"App\") {\n        text = \" \" + show(term[1].argm, canon, ctx) + text;\n        term = term[1].func;\n      }\n      return \"(\" + show(term, canon, ctx) + text;\n    case \"Put\":\n      var expr = show(args.expr, canon, ctx);\n      return \"#\" + expr;\n    case \"Dup\":\n      var name = args.name;\n      var expr = show(args.expr, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([name]));\n      return \"(dup \" + name + \" = \" + expr + \" \" + body + \")\";\n    case \"Num\":\n      return args.numb.toString();\n    case \"Op1\":\n    case \"Op2\":\n      var func = args.func;\n      var num0 = show(args.num0, canon, ctx);\n      var num1 = show(args.num1, canon, ctx);\n      return \"|\" + num0 + \" \" + func + \" \" + num1 + \"|\";\n    case \"Ite\":\n      var cond = show(args.cond, canon, ctx);\n      var pair = show(args.pair, canon, ctx);\n      return \"(if \" + cond + \" \" + pair + \")\";\n    case \"Cpy\":\n      var name = args.name;\n      var numb = show(args.numb, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([name]));\n      return \"(cpy \" + name + \" = \" + numb + \" \" + body + \")\";\n    case \"Par\":\n      var text = term_to_text([ctor, args]);\n      if (text !== null) {\n        return \"\\\"\" + text + \"\\\"\";\n      } else {\n        var val0 = show(args.val0, canon, ctx);\n        var val1 = show(args.val1, canon, ctx);\n        return \"[\" + val0 + \",\" + val1 + \"]\";\n      }\n    case \"Fst\":\n      var pair = show(args.pair, canon, ctx);\n      return \"(fst \" + pair + \")\";\n    case \"Snd\":\n      var pair = show(args.pair, canon, ctx);\n      return \"(snd \" + pair + \")\";\n    case \"Prj\":\n      var nam0 = args.nam0;\n      var nam1 = args.nam1;\n      var pair = show(args.pair, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([nam0, nam1]));\n      return \"(get [\" + nam0 + \",\" + nam1 + \"] = \" + pair + \" \" + body + \")\";\n    case \"Ref\":\n      return args.name;\n  }\n}\n\n// ::::::::::::::::::\n// :: Substitution ::\n// ::::::::::::::::::\n\n// Shifts a term\nconst shift = ([ctor, term], inc, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index < depth ? term.index : term.index + inc);\n    case \"Lam\":\n      var name = term.name;\n      var body = shift(term.body, inc, depth + 1);\n      return Lam(name, body);\n    case \"App\":\n      var func = shift(term.func, inc, depth);\n      var argm = shift(term.argm, inc, depth);\n      return App(func, argm);\n    case \"Put\":\n      var expr = shift(term.expr, inc, depth);\n      return Put(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = shift(term.expr, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Dup(name, expr, body);\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = shift(term.num0, inc, depth);\n      var num1 = shift(term.num1, inc, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = shift(term.cond, inc, depth);\n      var pair = shift(term.pair, inc, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = shift(term.numb, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Cpy(name, numb, body);\n    case \"Par\":\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      return Par(val0, val1);\n    case \"Fst\":\n      var pair = shift(term.pair, inc, depth);\n      return Fst(pair);\n    case \"Snd\":\n      var pair = shift(term.pair, inc, depth);\n      return Snd(pair);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = shift(term.pair, inc, depth);\n      var body = shift(term.body, inc, depth + 2);\n      return Prj(nam0, nam1, pair, body);\n    case \"Ref\":\n      return Ref(term.name);\n  }\n}\n\n// Substitution\nconst subst = ([ctor, term], val, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return depth === term.index ? val : Var(term.index - (term.index > depth ? 1 : 0));\n    case \"Lam\":\n      var name = term.name;\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Lam(name, body);\n    case \"App\":\n      var func = subst(term.func, val, depth);\n      var argm = subst(term.argm, val, depth);\n      return App(func, argm);\n    case \"Put\":\n      var expr = subst(term.expr, val, depth);\n      return Put(expr);\n    case \"Dup\": \n      var name = term.name;\n      var expr = subst(term.expr, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Dup(name, expr, body);\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = subst(term.num0, val, depth);\n      var num1 = subst(term.num1, val, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = subst(term.cond, val, depth);\n      var pair = subst(term.pair, val, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = subst(term.numb, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Cpy(name, numb, body);\n    case \"Par\":\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      return Par(val0, val1);\n    case \"Fst\":\n      var pair = subst(term.pair, val, depth);\n      return Fst(pair);\n    case \"Snd\":\n      var pair = subst(term.pair, val, depth);\n      return Snd(pair);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = subst(term.pair, val, depth);\n      var body = subst(term.body, val && shift(val, 2, 0), depth + 2);\n      return Prj(nam0, nam1, pair, body);\n    case \"Ref\":\n      var name = term.name;\n      return Ref(name);\n  }\n}\n\n// ::::::::::::::::::::\n// :: Stratification ::\n// ::::::::::::::::::::\n\n// How many times a variable was used in computational positions\nconst uses = ([ctor, term], depth = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index === depth ? 1 : 0;\n    case \"Lam\": return uses(term.body, depth + 1);\n    case \"App\": return uses(term.func, depth) + uses(term.argm, depth);\n    case \"Put\": return uses(term.expr, depth);\n    case \"Dup\": return uses(term.expr, depth) + uses(term.body, depth + 1);\n    case \"Num\": return 0;\n    case \"Op1\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Op2\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Ite\": return uses(term.cond, depth) + uses(term.pair, depth);\n    case \"Cpy\": return uses(term.numb, depth) + uses(term.body, depth + 1);\n    case \"Par\": return uses(term.val0, depth) + uses(term.val1, depth);\n    case \"Fst\": return uses(term.pair, depth);\n    case \"Snd\": return uses(term.pair, depth);\n    case \"Prj\": return uses(term.pair, depth) + uses(term.body, depth + 2);\n    case \"Ref\": return 0;\n  }\n}\n\n// Checks if variable only occurs at a specific relative level\nconst is_at_level = ([ctor, term], at_level, depth = 0, level = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index !== depth || level === at_level;\n    case \"Lam\": return is_at_level(term.body, at_level, depth + 1, level);\n    case \"App\": return is_at_level(term.func, at_level, depth, level) && is_at_level(term.argm, at_level, depth, level);\n    case \"Put\": return is_at_level(term.expr, at_level, depth, level + 1);\n    case \"Dup\": return is_at_level(term.expr, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Num\": return true;\n    case \"Op1\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Op2\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Ite\": return is_at_level(term.cond, at_level, depth, level) && is_at_level(term.pair, at_level, depth, level);\n    case \"Cpy\": return is_at_level(term.numb, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Par\": return is_at_level(term.val0, at_level, depth, level) && is_at_level(term.val1, at_level, depth, level);\n    case \"Fst\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Snd\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Prj\": return is_at_level(term.pair, at_level, depth, level) && is_at_level(term.body, at_level, depth + 2, level);\n    case \"Pri\": return is_at_level(term.argm, at_level, depth, level);\n    case \"Ref\": return true;\n  }\n}\n\n// Checks if a term is stratified\nconst check = ([ctor, term], defs = {}, ctx = []) => {\n  switch (ctor) {\n    case \"Lam\": \n      if (uses(term.body) > 1) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used more than once in:\\n\" + show([ctor, term], false, ctx);\n      }\n      if (!is_at_level(term.body, 0)) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used inside a box in:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"App\":\n      check(term.func, defs, ctx);\n      check(term.argm, defs, ctx);\n      break;\n    case \"Put\":\n      check(term.expr, defs, ctx);\n      break;\n    case \"Dup\":\n      if (!is_at_level(term.body, 1)) {\n        throw \"[ERROR]\\nDuplication variable `\" + term.name + \"` must always have exactly 1 enclosing box on the body of:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.expr, defs, ctx);\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Op1\":\n    case \"Op2\":\n      check(term.num0, defs, ctx);\n      check(term.num1, defs, ctx);\n      break;\n    case \"Ite\":\n      check(term.cond, defs, ctx);\n      check(term.pair, defs, ctx);\n      break;\n    case \"Cpy\":\n      check(term.numb, defs, ctx);\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Par\":\n      check(term.val0, defs, ctx);\n      check(term.val1, defs, ctx);\n      break;\n    case \"Fst\":\n      check(term.pair, defs, ctx);\n      break;\n    case \"Snd\":\n      check(term.pair, defs, ctx);\n      break;\n    case \"Prj\":\n      var uses0 = uses(term.body, 1);\n      var uses1 = uses(term.body, 0);\n      var isat0 = is_at_level(term.body, 0, 1);\n      var isat1 = is_at_level(term.body, 0, 0);\n      if (uses0 > 1 || uses1 > 1) {\n        throw \"[ERROR]\\nProjection variable `\" + (uses0 > 1 ? term.nam0 : term.nam1) + \"` used more than once in:\\n\" + show([ctor, term], false, ctx);\n      }\n      if (!isat0 || !isat1) {\n        throw \"[ERROR]\\nProjection variable `\" + (!isat0 ? term.nam0 : term.nam1) + \"` used inside a box in:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.pair, defs, ctx);\n      check(term.body, defs, ctx.concat([term.nam0, term.nam1]));\n      break;\n    case \"Ref\":\n      if (!defs[term.name]) {\n        throw \"[ERROR]\\nUndefined reference: \" + term.name;\n      } else {\n        check(defs[term.name], defs, ctx);\n        break;\n      }\n  }\n}\n\n// ::::::::::::::::\n// :: Evaluation ::\n// ::::::::::::::::\n\n// Reduces a term to normal form or head normal form\nconst norm = (term, defs = {}, to_lam = false) => {\n  var [ctor, term] = term;\n  const apply = (func, argm) => {\n    var func = norm(func, defs, to_lam);\n    // ([x]a b) ~> [b/x]a\n    if (func[0] === \"Lam\") {\n      return norm(subst(func[1].body, argm, 0), defs, to_lam);\n    // ([x = a] b c) ~> [x = a] (b c)\n    } else if (func[0] === \"Dup\") {\n      return norm(Dup(func[1].name, func[1].expr, App(func[1].body, shift(argm, 1, 0))), defs, to_lam);\n    // (|a b) ~> ⊥\n    } else if (func[0] === \"Put\") {\n      throw \"[RUNTIME-ERROR]\\nCan't apply a boxed value.\";\n    } else {\n      return App(norm(func, defs, to_lam), norm(argm, defs, to_lam));\n    }\n  }\n  const duplicate = (name, expr, body) => {\n    var expr = norm(expr, defs, to_lam);\n    // [x = |a] b ~> [a/x]b\n    if (expr[0] === \"Put\") {\n      return norm(subst(body, expr[1].expr, 0), defs, to_lam);\n    // [x = [y = a] b] c ~> [y = a] [x = b] c\n    } else if (expr[0] === \"Dup\") {\n      return norm(Dup(expr[1].name, expr[1].expr, Dup(name, expr[1].body, shift(body, 1, 1))), defs, to_lam); \n    // [x = [y] b] c ~> ⊥\n    } else if (expr[0] === \"Lam\") {\n      throw \"[RUNTIME-ERROR]\\nCan't duplicate a lambda.\";\n    } else {\n      return Dup(name, expr, norm(body, defs, to_lam));\n    }\n  }\n  const dereference = (name) => {\n    if (defs[name]) {\n      return norm(defs[name], defs, to_lam);\n    } else {\n      return Ref(name);\n    }\n  }\n  const op1 = (func, num0, num1) => {\n    var num0 = norm(num0, defs, to_lam);\n    if (num0[0] === \"Num\") {\n      switch (func) {\n        case \"+\"  : return Num((num0[1].numb + num1[1].numb) >>> 0);\n        case \"-\"  : return Num((num0[1].numb - num1[1].numb) >>> 0);\n        case \"*\"  : return Num((num0[1].numb * num1[1].numb) >>> 0);\n        case \"/\"  : return Num((num0[1].numb / num1[1].numb) >>> 0);\n        case \"%\"  : return Num((num0[1].numb % num1[1].numb) >>> 0);\n        case \"**\" : return Num((num0[1].numb ** num1[1].numb) >>> 0);\n        case \"^^\" : return Num((num0[1].numb ** (num1[1].numb / (2 ** 32))) >>> 0);\n        case \"&\"  : return Num((num0[1].numb & num1[1].numb) >>> 0);\n        case \"|\"  : return Num((num0[1].numb | num1[1].numb) >>> 0);\n        case \"^\"  : return Num((num0[1].numb ^ num1[1].numb) >>> 0);\n        case \"~\"  : return Num((~ num1[1].numb) >>> 0);\n        case \">>\" : return Num((num0[1].numb >>> num1[1].numb) >>> 0);\n        case \"<<\" : return Num((num0[1].numb << num1[1].numb) >>> 0);\n        case \">\"  : return Num((num0[1].numb > num1[1].numb ? 1 : 0) >>> 0);\n        case \"<\"  : return Num((num0[1].numb < num1[1].numb ? 1 : 0) >>> 0);\n        case \"==\" : return Num((num0[1].numb === num1[1].numb ? 1 : 0) >>> 0);\n        default   : throw \"[RUNTIME-ERROR]\\nUnknown primitive: \" + func + \".\";\n      }\n    } else {\n      return Op1(func, num0, norm(num1, defs, to_lam));\n    }\n  }\n  const op2 = (func, num0, num1) => {\n    var num1 = norm(num1, defs, to_lam);\n    if (num1[0] === \"Num\") {\n      return norm(Op1(func, num0, num1), defs, to_lam);\n    } else {\n      return Op2(func, norm(num0, defs, to_lam), num1);\n    }\n  }\n  const if_then_else = (cond, pair) => {\n    var cond = norm(cond, defs, to_lam);\n    if (cond[0] === \"Num\") {\n      return norm(cond[1].numb > 0 ? Fst(pair) : Snd(pair), defs, to_lam);\n    } else {\n      return Ite(cond, norm(pair, defs, to_lam));\n    }\n  }\n  const copy = (name, numb, body) => {\n    var numb = norm(numb, defs, to_lam);\n    if (numb[0] === \"Num\") {\n      return norm(subst(body, numb, 0), defs, to_lam);\n    } else {\n      return Cpy(name, numb, norm(body, defs, to_lam));\n    }\n  }\n  const first = (pair) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(pair[1].val0, defs, to_lam);\n    } else {\n      return Fst(pair);\n    }\n  }\n  const second = (pair) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(pair[1].val1, defs, to_lam);\n    } else {\n      return Snd(pair);\n    }\n  }\n  const case_of = (nam0, nam1, pair, body) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(subst(subst(body, shift(pair[1].val0, 1, 0), 1), pair[1].val1, 0), defs, to_lam);\n    } else {\n      return Prj(nam0, nam1, pair, norm(body, defs, to_lam));\n    }\n  }\n  if (to_lam && ctor === \"Put\") {\n    return norm(term.expr, defs, to_lam);\n  } else if (to_lam && ctor === \"Dup\") {\n    return norm(subst(term.body, term.expr, 0), defs, to_lam)\n  } else if (to_lam && ctor === \"Prj\") {\n    return norm(subst(subst(term.body, Fst(shift(term.pair, 1, 0)), 1), Snd(term.pair), 0), defs, to_lam);\n  } else if (to_lam && ctor === \"Cpy\") {\n    return norm(subst(term.body, term.numb, 0), defs, to_lam)\n  } else {\n    switch (ctor) {\n      case \"Var\": return Var(term.index);\n      case \"Lam\": return Lam(term.name, norm(term.body, defs, to_lam)); \n      case \"App\": return apply(term.func, term.argm);\n      case \"Put\": return Put(norm(term.expr, defs, to_lam));\n      case \"Dup\": return duplicate(term.name, term.expr, term.body);\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return op1(term.func, term.num0, term.num1);\n      case \"Op2\": return op2(term.func, term.num0, term.num1);\n      case \"Ite\": return if_then_else(term.cond, term.pair);\n      case \"Cpy\": return copy(term.name, term.numb, term.body);\n      case \"Par\": return Par(norm(term.val0, defs, to_lam), norm(term.val1, defs, to_lam));\n      case \"Fst\": return first(term.pair);\n      case \"Snd\": return second(term.pair);\n      case \"Prj\": return case_of(term.nam0, term.nam1, term.pair, term.body);\n      case \"Ref\": return dereference(term.name);\n    }\n  }\n}\n\n// ::::::::::::::\n// :: Equality ::\n// ::::::::::::::\n\n// Checks if two terms are equal\nconst equal = ([a_ctor, a_term], [b_ctor, b_term]) => {\n  switch (a_ctor + \"-\" + b_ctor) {\n    case \"var-var\": return a_term.index === b_term.index;\n    case \"lam-lam\": return equal(a_term.body, b_term.body);\n    case \"app-app\": return equal(a_term.func, b_term.func) && equal(a_term.argm, b_term.argm);\n    case \"put-put\": return equal(a_term.expr, b_term.expr);\n    case \"dup-dup\": return equal(a_term.expr, b_term.expr) && equal(a_term.body, b_term.body);\n    case \"ref-ref\": return a_term.name === b_term.name;\n    case \"num-num\": return a_term.numb === b_term.numb;\n    case \"op1-op1\": return a_term.func === b_term.func && equal(a_term.num0, b_term.num0) && a_term.num1 === a_term.num1;\n    case \"op2-op2\": return a_term.func === b_term.func && equal(a_term.num0, b_term.num0) && equal(a_term.num1, b_term.num1);\n    case \"ite-ite\": return equal(a_term.cond, b_term.cond) && equal(a_term.pair, b_term.pair);\n    case \"cpy-cpy\": return equal(a_term.numb, b_term.numb) && equal(a_term.body, b_term.body);\n    case \"par-par\": return equal(a_term.val0, b_term.val0) && equal(a_term.val1, b_term.val1);\n    case \"fst-fst\": return equal(a_term.pair, b_term.pair);\n    case \"snd-snd\": return equal(a_term.pair, b_term.pair);\n    case \"cas-cas\": return equal(a_term.pair, b_term.pair) && equal(a_term.body, b_term.body);\n    default: return false;\n  }\n}\n\n// :::::::::::::::::::\n// :: Syntax Sugars ::\n// :::::::::::::::::::\n\n// Converts an utf-8 string to a λ-encoded term\nconst text_to_term = (text) => {\n  // Converts UTF-8 to bytes\n  var bytes = [].slice.call(new TextEncoder(\"utf-8\").encode(text), 0);\n\n  // Converts bytes to uints\n  while (bytes.length % 4 !== 0) {\n    bytes.push(0);\n  }\n  var nums = new Uint32Array(new Uint8Array(bytes).buffer);\n\n  // Converts uints to C-List of nums\n  var term = Var(0);\n  for (var i = nums.length - 1; i >= 0; --i) {\n    term = App(App(Var(1), Num(nums[i])), term);\n  }\n  term = Par(Num(0x74786574), Lam(\"c\", Dup(\"c\", Var(0), Put(Lam(\"n\", term)))));\n  return term;\n}\n\n// Converts a λ-encoded term to a string, if possible\nconst term_to_text = (term) => {\n  try {\n    if (term[1].val0[1].numb === 0x74786574) {\n      try {\n        term = term[1].val1[1].body[1].body[1].expr[1].body;\n      } catch(e) {\n        term = term[1].val1[1].body[1].body;\n      }\n      var nums = [];\n      while (term[0] !== \"Var\") {\n        if (term[1].func[1].func[1].index !== 1) {\n          return null;\n        }\n        nums.push(term[1].func[1].argm[1].numb);\n        term = term[1].argm;\n      }\n      if (term[1].index !== 0) {\n        return null;\n      }\n      return new TextDecoder(\"utf-8\").decode(new Uint8Array(new Uint32Array(nums).buffer));\n    } else {\n      return null;\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\n// Converts a number to a λ-encoded nat for repeated application (bounded for-loop)\nconst numb_to_term = (numb) => {\n  var term = Var(0);\n  var log2 = Math.floor(Math.log(numb) / Math.log(2));\n  for (var i = 0; i < log2 + 1; ++i) {\n    term = (numb >>> (log2 - i)) & 1 ? App(Var(i + 1), term) : term;\n  }\n  term = Put(Lam(\"x\", term));\n  for (var i = 0; i < log2; ++i) {\n    term = Dup(\"s\" + (log2 - i), Put(Lam(\"x\", App(Var(1), App(Var(1), Var(0))))), term);\n  }\n  term = Lam(\"s\", Dup(\"s0\", Var(0), term));\n  return term;\n}\n\n// Converts a λ-encoded nat to a number, if possible\nconst term_to_numb = (term) => {\n  try {\n    try {\n      term = term[1].body[1].body[1].expr[1].body;\n    } catch(e) {\n      term = term[1].body[1].body;\n    }\n    var count = 0;\n    while (term[0] !== \"Var\") {\n      if (term[1].func[1].index !== 1) {\n        return null;\n      }\n      count++;\n      term = term[1].argm;\n    }\n    if (term[1].index !== 0) {\n      return null;\n    }\n    return count;\n  } catch (e) {\n    return null;\n  }\n}\n\nmodule.exports = {\n  Var, Ref, Lam, App, Put,\n  Dup, Num, Op1, Op2, Ite,\n  Cpy, Par, Fst, Snd, Prj,\n  gen_name,\n  parse,\n  show,\n  check,\n  norm,\n  equal\n};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-core.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-to-js.js":
/*!*************************************************!*\
  !*** ./node_modules/formality-core/fm-to-js.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fmc = __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\");\n\n// Converts a Formality-Core Term to a native JavaScript function\nconst compile = ([ctor, term], defs, vars) => {\n  switch (ctor) {\n    case \"Var\":\n      for (var i = 0; i < term.index; ++i) {\n        vars = vars[1];\n      }\n      return vars[0];\n    case \"Lam\":\n      return x => compile(term.body, defs, [x, vars]);\n    case \"App\":\n      var func = compile(term.func, defs, vars);\n      var argm = compile(term.argm, defs, vars);\n      return func(argm);\n    case \"Put\":\n      return compile(term.expr, defs, vars);\n    case \"Dup\": \n      var expr = compile(term.expr, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(expr);\n    case \"Num\":\n      return term.numb;\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = compile(term.num0, defs, vars);\n      var num1 = compile(term.num1, defs, vars);\n      switch (func) {\n        case \"+\"  : return (num0 + num1) >>> 0;\n        case \"-\"  : return (num0 - num1) >>> 0;\n        case \"*\"  : return (num0 * num1) >>> 0;\n        case \"/\"  : return (num0 / num1) >>> 0;\n        case \"%\"  : return (num0 % num1) >>> 0;\n        case \"**\" : return (num0 ** num1) >>> 0;\n        case \"^^\" : return (num0 ** (num1 / (2 ** 32))) >>> 0;\n        case \"&\"  : return (num0 & num1) >>> 0;\n        case \"|\"  : return (num0 | num1) >>> 0;\n        case \"^\"  : return (num0 ^ num1) >>> 0;\n        case \"~\"  : return (~ num1) >>> 0;\n        case \">>\" : return (num0 >>> num1) >>> 0;\n        case \"<<\" : return (num0 << num1) >>> 0;\n        case \">\"  : return (num0 > num1) >>> 0;\n        case \"<\"  : return (num0 < num1) >>> 0;\n        case \"==\" : return (num0 === num1) >>> 0;\n      }\n    case \"Ite\":\n      var cond = compile(term.cond, defs, vars);\n      var pair = compile(term.pair, defs, vars);\n      return cond ? pair[0] : pair[1];\n    case \"Cpy\":\n      var numb = compile(term.numb, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(numb);\n    case \"Par\":\n      var val0 = compile(term.val0, defs, vars);\n      var val1 = compile(term.val1, defs, vars);\n      return [val0, val1];\n    case \"Fst\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[0];\n    case \"Snd\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[1];\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = compile(term.pair, defs, vars);\n      var body = (x,y) => compile(term.body, defs, [y,[x,vars]]);\n      return body(pair[0], pair[1]);\n    case \"Ref\":\n      return compile(defs[term.name], defs, vars);\n  }\n};\n\n// Converts a native JavaScript function back to a Formality-Core term\nconst decompile = (func) => {\n  return (function go(term, depth) {\n    function APP(variable) {\n      return function FMC_DECOMPILE_GET(arg){\n        if (arg === null) {\n          return variable;\n        } else {\n          return APP(d => fmc.App(variable(d), go(arg, d)));\n        }\n      };\n    };\n    function VAR(d) {\n      return fmc.Var(d - 1 - depth);\n    };\n    if (typeof term === \"function\" && term.name === \"FMC_DECOMPILE_GET\") {\n      return term(null)(depth);\n    } else if (typeof term === \"object\") {\n      var val0 = go(term[0], depth);\n      var val1 = go(term[1], depth);\n      return fmc.Par(val0, val1);\n    } else if (typeof term === \"number\") {\n      return fmc.Num(term);\n    } else if (typeof term === \"function\") {\n      var body = go(term(APP(VAR)), depth + 1);\n      return fmc.Lam(fmc.gen_name(depth), body);\n    } else if (typeof term === \"string\") {\n      throw \"[ERROR]\\nThis native JS function can't be decompiled to FMC:\\n\\n\"\n        + func.toString()\n        + \"\\n\\nIt possibly uses numeric operators on free variables, which can't be decompiled yet.\";\n    } else {\n      return term;\n    }\n  })(func, 0);\n};\n\nmodule.exports = {compile, decompile};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-to-js.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-to-net.js":
/*!**************************************************!*\
  !*** ./node_modules/formality-core/fm-to-net.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ~~ Compiles Formality Core to Formality Net ~~\n\nconst {Var, App, Lam, Num, Op1, Op2, Ite, Par, Fst, Snd, gen_name} = __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\");\nconst {Net, Pointer, Numeric, addr_of, slot_of, type_of, numb_of, NOD, OP1, OP2, NUM, ITE, PTR, FOR} = __webpack_require__(/*! formality-net */ \"./node_modules/formality-net/fm-net.js\");\n\nconst op_kind = {\n   0 : \"+\"  , \"+\"  : 0, \n   1 : \"-\"  , \"-\"  : 1, \n   2 : \"*\"  , \"*\"  : 2, \n   3 : \"/\"  , \"/\"  : 3, \n   4 : \"%\"  , \"%\"  : 4,\n   5 : \"**\" , \"**\" : 5,\n   6 : \"^^\" , \"^^\" : 6,\n   7 : \"&\"  , \"&\"  : 7,\n   8 : \"|\"  , \"|\"  : 8,\n   9 : \"^\"  , \"^\"  : 9,\n  10 : \"~\"  , \"~\"  : 10,\n  11 : \">>\" , \">>\" : 11,\n  12 : \"<<\" , \"<<\" : 12,\n  13 : \">\"  , \">\"  : 13,\n  14 : \"<\"  , \"<\"  : 14,\n  15 : \"==\" , \"==\"  : 15,\n};\n\nconst compile = (term, defs = {}) => {\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return ptrn;\n      } else {\n        if (net.enter_port(ptrn) === ptrn) {\n          return ptrn;\n        } else {\n          var dups_ptrn = net.enter_port(ptrn);\n          var dup_addr = net.alloc_node(NOD, level_of[ptrn] + 1);\n          net.link_ports(Pointer(dup_addr, 0), ptrn);\n          net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n          return Pointer(dup_addr, 2);\n        }\n      }\n    };\n    switch (term[0]) {\n      case \"Dup\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level);\n        level_of[expr_ptr] = level;\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Put\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level + 1);\n        return expr_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(NOD, 0);\n        net.link_ports(Pointer(lam_addr, 1), Pointer(lam_addr, 1));\n        level_of[Pointer(lam_addr, 1)] = level;\n        var_ptrs.push(Pointer(lam_addr, 1));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(Pointer(lam_addr, 2), body_ptr);\n        return Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(NOD, 0);\n        var func_ptr = build_net(term[1].func, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term[1].argm, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 1), argm_ptr)\n        return Pointer(app_addr, 2);\n      case \"Num\":\n        return Numeric(term[1].numb >>> 0);\n      case \"Op1\":\n        var op1_addr = net.alloc_node(OP1, op_kind[term[1].func]);\n        net.link_ports(Numeric(term[1].num1[1].numb), Pointer(op1_addr, 1));\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(num0_ptr, Pointer(op1_addr, 0));\n        return Pointer(op1_addr, 2);\n      case \"Op2\":\n        var op2_addr = net.alloc_node(OP2, op_kind[term[1].func]);\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 1), num0_ptr);\n        var num1_ptr = build_net(term[1].num1, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 0), num1_ptr);\n        return Pointer(op2_addr, 2);\n      case \"Par\":\n        var par_addr = net.alloc_node(NOD, 0xFFFF);\n        var val0_ptr = build_net(term[1].val0, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 1), val0_ptr);\n        var val1_ptr = build_net(term[1].val1, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 2), val1_ptr);\n        return Pointer(par_addr, 0);\n      case \"Fst\":\n        var fst_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(fst_addr, 0), pair_ptr);\n        net.link_ports(Pointer(fst_addr, 2), Pointer(fst_addr, 2));\n        return Pointer(fst_addr, 1);\n      case \"Snd\":\n        var snd_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(snd_addr, 0), pair_ptr);\n        net.link_ports(Pointer(snd_addr, 1), Pointer(snd_addr, 1));\n        return Pointer(snd_addr, 2);\n      case \"Prj\":\n        var prj_addr = net.alloc_node(NOD, 0xFFFF);\n        level_of[Pointer(prj_addr, 1)] = level;\n        level_of[Pointer(prj_addr, 2)] = level;\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        var_ptrs.push(Pointer(prj_addr, 1));\n        var_ptrs.push(Pointer(prj_addr, 2));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        var_ptrs.pop();\n        net.link_ports(Pointer(prj_addr, 0), pair_ptr);\n        return body_ptr;\n      case \"Ite\":\n        var ite_addr = net.alloc_node(ITE, 0xFFFF);\n        var cond_ptr = build_net(term[1].cond, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 0), cond_ptr);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 1), pair_ptr);\n        return Pointer(ite_addr, 2);\n      case \"Cpy\":\n        var numb_ptr = build_net(term[1].numb, net, var_ptrs, level);\n        level_of[numb_ptr] = 0xFFFE;\n        var_ptrs.push(numb_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term[1].index - 1]);\n      case \"Ref\":\n        return build_net(defs[term[1].name], net, var_ptrs, level);\n      default:\n        return build_net(Lam(\"\", null, Var(0)), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(NOD, 0);\n  var term_ptr = build_net(term, net, [], 0);\n  net.link_ports(Pointer(root_addr, 0), Pointer(root_addr, 2));\n  net.link_ports(Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter((a_addr) => {\n    var b_ptrn = net.enter_port(Pointer(a_addr, 0));\n    if (type_of(b_ptrn) !== NUM) {\n      var b_addr = addr_of(b_ptrn);\n      var a_p0 = Pointer(a_addr, 0);\n      var b_p0 = Pointer(b_addr, 0);\n      var a_ok = net.enter_port(a_p0) === b_p0;\n      var b_ok = net.enter_port(b_p0) === a_p0;\n      return a_ok && b_ok;\n    } else {\n      return true;\n    }\n  });\n  return net;\n};\n\nconst decompile = (net) => {\n  const build_term = (net, ptrn, var_ptrs, dup_exit) => {\n    if (type_of(ptrn) === NUM) {\n      return Num(numb_of(ptrn));\n    } else {\n      var addr = addr_of(ptrn);\n      var type = net.type_of(addr);\n      var kind = net.kind_of(addr);\n      if (type === NOD) {\n        if (kind === 0) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var_ptrs.push(Pointer(addr, 1));\n              var body = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              var_ptrs.pop();\n              return Lam(gen_name(var_ptrs.length), body);\n            case 1:\n              for (var index = 0; index < var_ptrs.length; ++index) {\n                if (var_ptrs[var_ptrs.length - index - 1] === ptrn) {\n                  return Var(index);\n                }\n              }\n            case 2:\n              var argm = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var func = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return App(func, argm);\n          }\n        } else if (kind === 0xFFFF) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var val0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var val1 = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              return Par(val0, val1);\n            case 1:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Fst(pair);\n            case 2:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Snd(pair);\n          }\n        } else {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var exit = dup_exit.pop();\n              var term = build_term(net, net.enter_port(Pointer(addr, exit)), var_ptrs, dup_exit);\n              dup_exit.push(exit);\n              return term;\n            default:\n              dup_exit.push(slot_of(ptrn));\n              var term = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              dup_exit.pop();\n              return term;\n          }\n        }\n      } else if (type === OP1) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var num1 = Num(numb_of(net.enter_port(Pointer(addr, 1))));\n        return Op1(op_kind[kind], num0, num1);\n      } else if (type === OP2) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        var num1 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        return Op2(op_kind[kind], num0, num1);\n      } else if (type === ITE) {\n        var cond = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var pair = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        return Ite(cond, pair);\n      }\n    }\n  };\n  return build_term(net, net.enter_port(Pointer(0, 1)), [], []);\n};\n\nconst norm_with_stats = (term, defs = {}, lazy = true) => {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var norm = decompile(net);\n  return {norm, stats};\n};\n\nconst norm = (term, defs, lazy) => {\n  return norm_with_stats(term, defs, lazy).norm;\n};\n\nmodule.exports = {compile, decompile, norm_with_stats, norm};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-to-net.js?");

/***/ }),

/***/ "./node_modules/formality-net/fm-net.js":
/*!**********************************************!*\
  !*** ./node_modules/formality-net/fm-net.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Interaction Net System ~~\n\nconst Pointer = (addr, port) => (addr << 2) + (port & 3);\nconst addr_of = (ptr) => ptr >>> 2;\nconst slot_of = (ptr) => ptr & 3;\nconst Numeric = (numb) => numb + 0x100000000;\nconst numb_of = (numb) => numb - 0x100000000;\nconst type_of = (ptrn) => ptrn >= 0x100000000 ? NUM : PTR;\n\n// PtrNum types\nconst PTR = 0;\nconst NUM = 1;\n\n// Node types\nconst NOD = 0;\nconst OP1 = 1;\nconst OP2 = 2;\nconst ITE = 3;\n\nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n    this.find_redex = true;\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(type, kind) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n\n    // Otherwise, extend the array of nodes\n    } else {\n      var addr = this.nodes.length / 4;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = (kind << 6) + ((type & 0x7) << 3);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = 0;\n    this.freed.push(addr);\n  }\n\n  is_free(addr) {\n    return this.nodes[addr * 4 + 0] === addr * 4 + 0\n        && this.nodes[addr * 4 + 1] === addr * 4 + 1\n        && this.nodes[addr * 4 + 2] === addr * 4 + 2\n        && this.nodes[addr * 4 + 3] === 0;\n  }\n\n  // Returns if given slot holds a number\n  is_numeric(addr, slot) {\n    return (this.nodes[addr * 4 + 3] >>> slot) & 1; \n  }\n\n  set_port(addr, slot, ptrn) {\n    if (type_of(ptrn) === NUM) {\n      this.nodes[addr * 4 + slot] = numb_of(ptrn);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] | (1 << slot);\n    } else {\n      this.nodes[addr * 4 + slot] = ptrn;\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] & ~(1 << slot);\n    }\n  }\n\n  get_port(addr, slot) {\n    return this.nodes[addr * 4 + slot] + (this.is_numeric(addr, slot) ? 0x100000000 : 0);\n  }\n\n  type_of(addr) {\n    return (this.nodes[addr * 4 + 3] >>> 3) & 0x7;\n  }\n\n  set_type(addr, type) {\n    this.nodes[addr * 4 + 3] = (this.nodes[addr * 4 + 3] & ~0b111000) | (type << 3);\n  }\n\n  kind_of(addr) {\n    return this.nodes[addr * 4 + 3] >>> 6;\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptrn) {\n    if (type_of(ptrn) === NUM) { \n      throw \"Can't enter a numeric pointer.\";\n    } else {\n      return this.get_port(addr_of(ptrn), slot_of(ptrn));\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptrn, b_ptrn) {\n    var a_numb = type_of(a_ptrn) === NUM;\n    var b_numb = type_of(b_ptrn) === NUM;\n\n    // Point ports to each-other\n    if (!a_numb) this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), b_ptrn);\n    if (!b_numb) this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), a_ptrn);\n\n    // If both are main ports, add this to the list of active pairs\n    if (this.find_redex && !(a_numb && b_numb) && (a_numb || slot_of(a_ptrn) === 0) && (b_numb || slot_of(b_ptrn) === 0)) {\n      this.redex.push(a_numb ? addr_of(b_ptrn) : addr_of(a_ptrn));\n    }\n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptrn) {\n    if (type_of(a_ptrn) === PTR) {\n      var b_ptrn = this.enter_port(a_ptrn);\n      if (type_of(b_ptrn) === PTR && this.enter_port(b_ptrn) === a_ptrn) {\n        this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), a_ptrn);\n        this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), b_ptrn);\n      }\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite(a_addr) {\n    var a_ptrn = Pointer(a_addr, 0);\n    var b_ptrn = this.get_port(a_addr, 0);\n    if (type_of(b_ptrn) === NUM) {\n      var a_type = this.type_of(a_addr);\n      var a_kind = this.kind_of(a_addr);\n\n      // UnaryOperation\n      if (a_type === OP1) {\n        var dst = this.enter_port(Pointer(a_addr, 2));\n        var fst = numb_of(b_ptrn);\n        var snd = numb_of(this.enter_port(Pointer(a_addr, 1)));\n        switch (a_kind) {\n          case  0: var res = Numeric((fst + snd) >>> 0); break;\n          case  1: var res = Numeric((fst - snd) >>> 0); break;\n          case  2: var res = Numeric((fst * snd) >>> 0); break;\n          case  3: var res = Numeric((fst / snd) >>> 0); break;\n          case  4: var res = Numeric((fst % snd) >>> 0); break;\n          case  5: var res = Numeric((fst ** snd) >>> 0); break;\n          case  6: var res = Numeric((fst ** (snd / (2 ** 32)) >>> 0)); break;\n          case  7: var res = Numeric((fst & snd) >>> 0); break;\n          case  8: var res = Numeric((fst | snd) >>> 0); break;\n          case  9: var res = Numeric((fst ^ snd) >>> 0); break;\n          case 10: var res = Numeric((~snd) >>> 0); break;\n          case 11: var res = Numeric((fst >>> snd) >>> 0); break;\n          case 12: var res = Numeric((fst << snd) >>> 0); break;\n          case 13: var res = Numeric((fst > snd ? 1 : 0) >>> 0); break;\n          case 14: var res = Numeric((fst < snd ? 1 : 0) >>> 0); break;\n          case 15: var res = Numeric((fst == snd ? 1 : 0) >>> 0); break;\n          default: throw \"[ERROR]\\nInvalid interaction.\";\n        }\n        this.link_ports(dst, res);\n        this.unlink_port(Pointer(a_addr, 0));\n        this.unlink_port(Pointer(a_addr, 2));\n        this.free_node(a_addr);\n      \n      // BinaryOperation\n      } else if (a_type === OP2) {\n        this.set_type(a_addr, OP1);\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.unlink_port(Pointer(a_addr, 1));\n        this.link_ports(Pointer(a_addr, 1), b_ptrn);\n    \n      // NumberDuplication\n      } else if (a_type === NOD) {\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 2)));\n        this.free_node(a_addr);\n\n      // IfThenElse\n      } else if (a_type === ITE) {\n        var pair_ptr = this.enter_port(Pointer(a_addr, 1));\n        var dest_ptr = this.enter_port(Pointer(a_addr, 2));\n        var cond_val = numb_of(b_ptrn) === 0;\n        this.set_type(a_addr, NOD);\n        this.link_ports(Pointer(a_addr, 0), pair_ptr);\n        this.link_ports(Pointer(a_addr, cond_val ? 1 : 2), Pointer(a_addr, cond_val ? 1 : 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 2 : 1), dest_ptr);\n\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n\n    } else {\n      var b_addr = addr_of(b_ptrn);\n      var a_type = this.type_of(a_addr);\n      var b_type = this.type_of(b_addr);\n      var a_kind = this.kind_of(a_addr);\n      var b_kind = this.kind_of(b_addr);\n\n      // NodeAnnihilation, UnaryAnnihilation, BinaryAnnihilation\n      if ( a_type === NOD && b_type === NOD && a_kind === b_kind\n        || a_type === OP1 && b_type === OP1\n        || a_type === OP2 && b_type === OP2\n        || a_type === ITE && b_type === ITE) {\n        var a_aux1_dest = this.enter_port(Pointer(a_addr, 1));\n        var b_aux1_dest = this.enter_port(Pointer(b_addr, 1));\n        this.link_ports(a_aux1_dest, b_aux1_dest);\n        var a_aux2_dest = this.enter_port(Pointer(a_addr, 2));\n        var b_aux2_dest = this.enter_port(Pointer(b_addr, 2));\n        this.link_ports(a_aux2_dest, b_aux2_dest);\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // NodeDuplication, BinaryDuplication\n      } else if\n        (  a_type === NOD && b_type === NOD && a_kind !== b_kind\n        || a_type === NOD && b_type === OP2\n        || a_type === NOD && b_type === ITE) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var r_addr = this.alloc_node(a_type, a_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(r_addr, 1), Pointer(p_addr, 1));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(r_addr, 2), Pointer(q_addr, 1));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(r_addr, 0), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // UnaryDuplication\n      } else if\n        (  a_type === NOD && b_type === OP1\n        || a_type === ITE && b_type === OP1) {\n        var c_addr = this.alloc_node(OP1, b_kind);\n        this.link_ports(Pointer(c_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        this.link_ports(this.enter_port(Pointer(a_addr, 1)), Pointer(b_addr, 0));\n        this.link_ports(this.enter_port(Pointer(a_addr, 2)), Pointer(c_addr, 0));\n        this.link_ports(Pointer(a_addr, 1), Pointer(b_addr, 2));\n        this.link_ports(Pointer(a_addr, 2), Pointer(c_addr, 2));\n      \n      // Permutations\n      } else if (a_type === OP1 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === OP2 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === ITE && b_type === NOD) {\n        return this.rewrite(b_addr);\n\n      // InvalidInteraction\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This could be performed in parallel and doesn't need GC.\n  reduce_strict(stats) {\n    var rewrites = 0;\n    var loops = 0;\n    var max_len = 0;\n    while (this.redex.length > 0) {\n      for (var i = 0, l = this.redex.length; i < l; ++i) {\n        this.rewrite(this.redex.pop());\n        stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n        ++stats.rewrites;\n      }\n      ++stats.loops;\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This avoids unecessary computations, but is sequential and would need GC.\n  reduce_lazy(stats) {\n    this.find_redex = false;\n    var warp = [];\n    var back = [];\n    var prev = Pointer(0, 1);\n    var next = this.enter_port(prev);\n    var rwts = 0;\n    while (true) {\n      ++stats.loops;\n      if (type_of(next) === PTR && (addr_of(next) === 0 || this.is_free(addr_of(next)))) {\n        if (warp.length === 0) {\n          break;\n        } else {\n          prev = warp.pop();\n          next = this.enter_port(prev);\n        }\n      } else {\n        if (slot_of(prev) === 0 && (type_of(next) === NUM || slot_of(next) === 0)) {\n          this.rewrite(addr_of(prev));\n          stats.rewrites += 1;\n          stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n          do { prev = back.pop(); } while (type_of(prev) !== PTR);\n          next = this.enter_port(prev);\n          ++rwts;\n        } else if (type_of(next) === NUM) {\n          [prev,next] = [next,prev];\n        } else if (slot_of(next) === 0) {\n          if (this.type_of(addr_of(next)) !== OP1) {\n            warp.push(Pointer(addr_of(next), 1));\n          }\n          prev = Pointer(addr_of(next), 2);\n          next = this.enter_port(prev);\n        } else {\n          back.push(prev);\n          prev = Pointer(addr_of(next), 0);\n          next = this.enter_port(prev);\n        }\n      }\n    }\n    this.find_redex = true;\n  }\n\n  // Returns a string that is preserved on reduction, good for debugging\n  denote(ptrn = this.enter_port(Pointer(0, 1)), exit = []) {\n    function path_to_string(path) {\n      var str = \"<\";\n      while (path) {\n        str += path.head === 1 ? \"a\" : \"b\";\n        path = path.tail; \n      }\n      str += \">\";\n      return str;\n    }\n    while (true) {\n      if (type_of(ptrn) === PTR) {\n        var ai = addr_of(ptrn);\n        var as = slot_of(ptrn)\n        var ak = this.kind_of(ai);\n        switch (this.type_of(ai)) {\n          case NOD:\n            if (slot_of(ptrn) === 0) {\n              if (exit[ak]) {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = new_exit[ak].tail;\n                ptrn = this.enter_port(Pointer(ai, Number(exit[ak].head)));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              } else {\n                var lft = this.denote(this.enter_port(Pointer(ai, 1)), exit);\n                var rgt = this.denote(this.enter_port(Pointer(ai, 2)), exit);\n                return \"(\" + ak + \" \" + lft + \" \" + rgt + \")\";\n              }\n            } else {\n              if (ai === 0) {\n                while (exit[exit.length - 1] === null) exit.pop();\n                return exit.map(path_to_string).join(\":\");\n              } else {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = {head: as, tail: new_exit[ak] || null};\n                ptrn = this.enter_port(Pointer(ai, 0));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              }\n            }\n            break;\n          default:\n            return \"<TODO>\";\n        }\n      } else {\n        return \"#\" + numb_of(ptrn);\n      }\n    }\n  }\n\n  to_string() {\n    const pointer = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return \"#\" + numb_of(ptrn);\n      } else {\n        return addr_of(ptrn) + \"abc\"[slot_of(ptrn)];\n      }\n    };\n    var text = '';\n    for (var i = 0; i < this.nodes.length / 4; i++) {\n      if (this.is_free(i)) {\n        text += i + \": ~\\n\";\n      } else {\n        var type = this.type_of(i);\n        var kind = this.kind_of(i);\n        text += i + ': ';\n        text += \"[\" + type + \":\" + kind + \"| \";\n        text += pointer(this.get_port(i, 0)) + \" \";\n        text += pointer(this.get_port(i, 1)) + \" \";\n        text += pointer(this.get_port(i, 2)) + \"]\";\n        text += \"...\" + this.is_numeric(i,0) + \" \" + this.is_numeric(i,1) + \" \" + this.is_numeric(i,2);\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, addr_of, slot_of, Numeric, numb_of, type_of, Net, NUM, PTR, NOD, OP1, OP2, ITE};\n\n\n//# sourceURL=webpack:///./node_modules/formality-net/fm-net.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/canvas.js":
/*!***********************!*\
  !*** ./src/canvas.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Creates a new canvas\nfunction Canvas(width, height) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = width * 2;\n  canvas.height = height * 2;\n  canvas.style.width = width + \"px\";\n  canvas.style.height = height + \"px\";\n  canvas.style.margin = \"0px\";\n  canvas.style.padding = \"0px\";\n\n  var context = canvas.getContext(\"2d\");\n  context.imageSmoothingEnabled = false;\n  context.font = \"10px Arial\";\n  context.textBaseline = \"middle\"; \n  context.textAlign = \"center\";\n\n  canvas.context = context;\n  canvas.context.scale(2,2);\n  return canvas;\n};\n\nmodule.exports = Canvas;\n\n\n//# sourceURL=webpack:///./src/canvas.js?");

/***/ }),

/***/ "./src/image.js":
/*!**********************!*\
  !*** ./src/image.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Image\nconst Image = (src) => {\n  var image = document.createElement(\"img\");\n  image.src = \"img/\" + src;\n  //image.onload = () => {\n    //if (flip) offset[0] = - offset[0];\n    //offset[0] -= image.width * 0.5;\n    //offset[1] -= image.height * 0.5;\n  //};\n  //image.offset = offset;\n  //document.body.appendChild(image);\n  return image;\n};\n\n// Images\nconst images = {\n  effects: {\n    shadow_flux: [\n      Image(\"effects/shadow_flux/shadow_flux-0.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-1.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-2.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-3.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-4.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-5.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-6.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-7.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-8.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-9.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-10.png\"),\n    ]\n  },\n  item: {\n    hourglass: Image(\"item/hourglass.png\")\n  },\n  tophoro: {\n    left: [\n      Image(\"heroes/tophoro.png\"),\n    ]\n  },\n  gonk: {\n    left: [\n      Image(\"heroes/gonk.png\"),\n    ]\n  },\n  stanci: {\n    left: [\n      Image(\"heroes/stanci.png\"),\n    ]\n  },\n  erkos: {\n    left: [\n      Image(\"heroes/erkos.png\"),\n    ]\n  },\n  croni: {\n    idle: {\n      left: [\n        Image(\"croni/Idle/Croni_Idle_00.png\"),\n        Image(\"croni/Idle/Croni_Idle_01.png\"),\n        Image(\"croni/Idle/Croni_Idle_02.png\"),\n        Image(\"croni/Idle/Croni_Idle_03.png\"),\n        Image(\"croni/Idle/Croni_Idle_04.png\"),\n        Image(\"croni/Idle/Croni_Idle_05.png\"),\n        Image(\"croni/Idle/Croni_Idle_06.png\"),\n        Image(\"croni/Idle/Croni_Idle_07.png\"),\n        Image(\"croni/Idle/Croni_Idle_08.png\"),\n        Image(\"croni/Idle/Croni_Idle_09.png\"),\n        Image(\"croni/Idle/Croni_Idle_10.png\"),\n        Image(\"croni/Idle/Croni_Idle_11.png\"),\n        Image(\"croni/Idle/Croni_Idle_12.png\"),\n        Image(\"croni/Idle/Croni_Idle_13.png\"),\n        Image(\"croni/Idle/Croni_Idle_14.png\"),\n        Image(\"croni/Idle/Croni_Idle_15.png\"),\n        Image(\"croni/Idle/Croni_Idle_16.png\"),\n        Image(\"croni/Idle/Croni_Idle_17.png\"),\n        Image(\"croni/Idle/Croni_Idle_18.png\"),\n        Image(\"croni/Idle/Croni_Idle_19.png\"),\n        Image(\"croni/Idle/Croni_Idle_20.png\"),\n        Image(\"croni/Idle/Croni_Idle_21.png\"),\n        Image(\"croni/Idle/Croni_Idle_22.png\"),\n        Image(\"croni/Idle/Croni_Idle_23.png\"),\n      ]\n    },\n    move: {\n      left: [\n        Image(\"croni/Move_LR/Croni_Move_LR_0.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_1.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_2.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_3.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_4.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_5.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_6.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_7.png\"),\n      ]\n    },\n    shadow_flux: {\n      left: [\n        Image(\"croni/Attack_LR/Croni_Attack_LR_00.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_01.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_02.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_03.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_04.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_05.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_06.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_07.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_08.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_09.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_10.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_11.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_12.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_13.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_14.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_15.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_16.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_17.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_18.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_19.png\"),\n      ]\n    }\n  },\n  snarch: {\n    left: [\n      Image(\"heroes/snarch.png\"),\n    ]\n  },\n  sirpix: {\n    left: [\n      Image(\"heroes/sirpix.png\"),\n    ]\n  },\n  kenlua: {\n    left: [\n      Image(\"heroes/kenlua.png\"),\n    ]\n  },\n  flina: {\n    left: [\n      Image(\"heroes/flina.png\"),\n    ]\n  },\n  zagatur: {\n    left: [\n      Image(\"heroes/zagatur.png\"),\n    ]\n  },\n  agdris: {\n    left: [\n      Image(\"heroes/agdris.png\"),\n    ]\n  },\n  mewem: {\n    left: [\n      Image(\"heroes/mewem.png\"),\n    ]\n  },\n  //thief: {\n    //right: [\n      //Image(\"thief/frame_00r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_01r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_02r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_03r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_04r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_05r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_06r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_07r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_08r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_09r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_10r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_11r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_12r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_13r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_14r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_15r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_16r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_17r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_18r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_19r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_20r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_21r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_22r.gif\", [-28,-16], 1),\n    //],\n    //left: [\n      //Image(\"thief/frame_00.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_01.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_02.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_03.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_04.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_05.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_06.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_07.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_08.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_09.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_10.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_11.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_12.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_13.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_14.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_15.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_16.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_17.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_18.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_19.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_20.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_21.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_22.gif\", [-28,-16], 0),\n    //],\n  //}\n};\n\nmodule.exports = {Image, images};\n\n\n//# sourceURL=webpack:///./src/image.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ::::::::::\n// :: Game ::\n// ::::::::::\n\nconst images     = __webpack_require__(/*! ./image.js */ \"./src/image.js\").images;\nconst Keyboard   = __webpack_require__(/*! ./keyboard.js */ \"./src/keyboard.js\");\nconst Canvas     = __webpack_require__(/*! ./canvas.js */ \"./src/canvas.js\");\nconst kaelin     = __webpack_require__(/*! ./kaelin.js */ \"./src/kaelin.js\");\nconst parse_cast = __webpack_require__(/*! ./parse_cast.js */ \"./src/parse_cast.js\");\nconst dist       = ([ax,ay],[bx,by]) => Math.abs(ax-bx) + Math.abs(ay-by);\nconst CAST_TIME  = 8;\nconst TICK_TIME  = 2.0;\nconst now        = () => Date.now() / 1000;\n\n// Renders the board to a canvas\nconst tile_size    = 32;\nconst pos_to_coord = ([i,j]) => [(i + 0.5) * tile_size, (j + 0.5) * tile_size];\nconst coord_to_pos = ([x,y]) => [Math.max(0, Math.min(Math.floor(x / tile_size - 0.5), 15)), Math.max(0, Math.min(Math.floor(y / tile_size - 0.5), 15))];\n\n// Renders the game\nconst render_game = (game, canvas) => {\n\n  var tick = game.ticks[Math.floor(game.index)];\n  var board = kaelin.board_to_json(tick.board);\n\n  var prev_tick = game.ticks[Math.floor(Math.max(game.index - 1, 0))];\n  var prev_board = kaelin.board_to_json(prev_tick.board);\n\n  // Finds hero positions\n  var hero_pos = {};\n  var prev_hero_pos = {};\n  for (var j = 0; j < 16; ++j) {\n    for (var i = 0; i < 16; ++i) {\n      var unit = board[j * 16 + i];\n      if (isHero(unit)) {\n        hero_pos[unit[1].hero] = [i,j];\n      }\n      var prev_unit = prev_board[j * 16 + i];\n      if (isHero(prev_unit)) {\n        prev_hero_pos[prev_unit[1].hero] = [i,j];\n      }\n    }\n  }\n\n  // Clears screen\n  canvas.context.clearRect(0, 0, canvas.width, canvas.height);\n  if (game.index < game.ticks.length - 1) {\n    canvas.context.fillStyle = \"rgb(200,200,200)\";\n  } else {\n    canvas.context.fillStyle = \"rgb(230,230,230)\";\n  }\n  canvas.context.rect(0, 0, canvas.width, canvas.height);\n  canvas.context.fill();\n\n  // Renders turn info\n  if (game.casting && now() - game.casting < CAST_TIME) {\n    var top_text = \"Casting in \" + (CAST_TIME - (now() - game.casting)).toFixed(2) + \" seconds...\";\n  } else {\n    var top_text = tick.text;\n  }\n  var bottom_text = \"Tick \" + Math.floor(game.index) + \"/\" + (game.ticks.length - 1) + \", Turn \" + tick.turn + \".\";\n  canvas.context.font = \"12px monospace\";\n  canvas.context.textAlign = \"center\"; \n  canvas.context.textBaseline = \"middle\"; \n  canvas.context.fillStyle = \"black\";\n  canvas.context.fillText(bottom_text, tile_size * 8, tile_size * 16.75);\n  canvas.context.fillText(top_text, tile_size * 8, tile_size * 0.25);\n\n  // Draws tiles\n  for (var j = 0; j < 16; ++j) {\n    for (var i = 0; i < 16; ++i) {\n      var [x,y] = pos_to_coord([i,j]);\n      canvas.context.beginPath();\n      canvas.context.rect(x, y, tile_size, tile_size);\n      var unit = board[j * 16 + i];\n\n      // Highlights hero walk range\n      if (  game.my_hero\n        && hero_pos[game.my_hero]\n        && dist([i,j], hero_pos[game.my_hero]) <= 3\n        && game.casting && now() - game.casting < CAST_TIME) {\n        canvas.context.fillStyle = \"rgba(64,128,64,0.3)\";\n        canvas.context.fill();\n      }\n\n      // Highlights target & caster positions\n      if (tick.cast) {\n        if (dist(tick.cast[1], [i,j]) <= kaelin.get_skill_area(tick.cast[0])) {\n          if (tick.cast[0] % 4 === 0) { // Moving to position\n            canvas.context.fillStyle = \"rgba(32,128,128,0.5)\";\n          } else { // Skill area       \n            canvas.context.fillStyle = \"rgba(128,32,32,0.5)\";\n          }\n          canvas.context.fill();\n        }\n        // Caster position\n        if (isHero(unit) && unit[1].hero === Math.floor(tick.cast[0] / 4)) {\n          canvas.context.fillStyle = \"rgba(64,64,64,0.3)\";\n          canvas.context.fill();\n        }\n      }\n      canvas.context.strokeStyle = \"rgba(128,128,128,0.15)\";\n      canvas.context.stroke();\n      canvas.context.closePath();\n      // Coordinate\n      canvas.context.font = \"10px courier new\";\n      canvas.context.textAlign = \"center\"; \n      canvas.context.textBaseline = \"middle\"; \n      canvas.context.fillStyle = \"rgb(64,64,64)\";\n      canvas.context.fillText(String(i.toString(16)) + String(j.toString(16)), x + tile_size * 0.5, y + tile_size * 0.5);\n    }\n  }\n\n  // Draws units\n  for (var j = 0; j < 16; ++j) {\n    for (var i = 0; i < 16; ++i) {\n      var [x,y] = pos_to_coord([i,j]);\n      var unit  = board[j * 16 + i];\n      switch (unit[0]) {\n        case \"Void\":\n          break;\n        case \"Item\":\n          if (unit[1].type === 2) {\n            var image = images.item.hourglass;\n            canvas.context.drawImage(image, x + tile_size * 0.5 - image.width / 2, y + tile_size * 0.5 - image.height / 2);\n          } else {\n            canvas.context.fillStyle = \"rgb(64,64,64)\";\n            canvas.context.beginPath();\n            canvas.context.rect(x, y, tile_size, tile_size);\n            canvas.context.fill();\n            canvas.context.closePath();\n          }\n          break;\n        case \"Goal\":\n          canvas.context.fillStyle = \"rgb(128,64,64)\";\n          canvas.context.beginPath();\n          canvas.context.rect(x, y, tile_size, tile_size);\n          canvas.context.fill();\n          canvas.context.closePath();\n          break;\n        case \"Hero\":\n          canvas.context.font = \"bold 10px courier new\";\n          canvas.context.textAlign = \"center\"; \n          canvas.context.textBaseline = \"middle\"; \n          canvas.context.fillStyle = \"black\";\n          canvas.context.fillText(\n            unit[1].life\n            + (unit[1].defs ? \"+\" + unit[1].defs : \"\")\n            + (unit[1].lock > 0 ? \"L\" : \"\")\n            + (unit[1].mute > 0 ? \"M\" : \"\")\n            + (unit[1].spec > 0 ? \"*\" : \"\"),\n            x + 16,\n            y + 27);\n          var hero = getHeroCode(unit);\n          var name = getHeroName(hero); // TODO: por que da erro ao colocar .toLowerCase() aqui\n          var delta = now() - (game.begin_anim || 0);\n          var prev_pos = prev_hero_pos[hero];\n\n          if (images[name.toLowerCase()].move !== undefined && canHeroAnimateSkill(tick, hero, 0)) { // have animation to move\n            var [px,py] = pos_to_coord(prev_hero_pos[hero]);\n            var x = px + (x - px) * delta / TICK_TIME;\n            var y = py + (y - py) * delta / TICK_TIME;\n            var frames = images[name.toLowerCase()].move.left;\n            var image = frames[Math.floor(delta * 10) % frames.length];\n          } else if (images[name.toLowerCase()].left !== undefined){ // Heros without animation\n            var image = images[name.toLowerCase()].left[0]; \n          } else {\n            if (name == \"Croni\") { // Croni is a special case because have some animations\n              if (canHeroAnimateSkill(tick, hero, 3)) {\n                var frames = images[name.toLowerCase()].shadow_flux.left;\n                if (delta > 0.7 && delta < 1.8) {\n                  var effect = images.effects.shadow_flux[Math.min(Math.floor((delta - 0.7) * 10), 10)];\n                  var [tx,ty] = pos_to_coord(tick.cast[1]);\n                  canvas.context.drawImage(effect, tx + tile_size * 0.5 - effect.width / 2, ty + tile_size * 0.5 - effect.height / 2);\n                }          \n              } else {\n                var frames = images[name.toLowerCase()].idle.left;\n              }\n              var image = frames[Math.floor(delta * 10) % frames.length];\n            }\n          }\n\n          canvas.context.drawImage(image, x + tile_size * 0.5 - image.width / 2, y + tile_size * 0.5 - image.height / 2);\n          break;\n      }\n    }\n  }\n\n  // Mark the tile where casting a skill\n  if (game.my_hero !== null) {\n    for (var n = 0; n < 4; ++n) {\n      if (game.my_casts[n]) {\n        var [i,j] = game.my_casts[n];\n        var [x,y] = pos_to_coord([i,j]);\n        canvas.context.font = \"bold 24px monospace\";\n        canvas.context.textAlign = \"center\"; \n        canvas.context.textBaseline = \"middle\"; \n        canvas.context.fillStyle = \"black\";\n        canvas.context.fillText(\"XSDF\"[n], x + tile_size * 0.5, y + tile_size * 0.5);\n      }\n    }\n      \n  }\n};\n\n// TODO: check if a hero has an animation to run, if not, shows an image\nfunction canHeroAnimateSkill(tick, hero, idSkill) {\n  var heroName = getHeroName(hero).toLowerCase();\n  var canPerform = tick.cast && Math.floor(tick.cast[0] / 4) === hero && tick.cast[0] % 4 === idSkill;\n\n  if ((images[heroName].move !== undefined) && canPerform && idSkill === 0) {\n    // console.log(\"yes\");\n  } else {\n    // console.log(\"no\")\n  }\n  return canPerform;\n}\n\n\n\nfunction isCastingTurn(game) {\n  return game.casting && now() - game.casting < CAST_TIME;\n}\n\nconst fm_string_to_string = str => {\n  var read_4_chars = n => {\n    var str = \"\";\n    str += String.fromCharCode((n >>>  0) & 0xFF);\n    str += String.fromCharCode((n >>>  8) & 0xFF);\n    str += String.fromCharCode((n >>> 16) & 0xFF);\n    str += String.fromCharCode((n >>> 24) & 0xFF);\n    return str;\n  };\n  return str[1](w => ws => read_4_chars(w) + ws)(\"\");\n};\n\nconst serialize_casts = (game) => {\n  if (game.my_hero !== null) {\n    var cast = \"@\" + kaelin.hero_name[game.my_hero].slice(0, 2).toLowerCase();\n    for (var n = 0; n < 4; ++n) {\n      var pos = game.my_casts[n];\n      cast += \" \" + (pos ? pos[0].toString(16) + pos[1].toString(16) : \".\");\n    }\n    return cast;\n  } else {\n    return null;\n  }\n};\n\nfunction isHero(unit) {\n  return unit[0] === \"Hero\";\n}\n\nfunction getHeroCode(unit) {\n  return unit[1].hero;\n}\n\nfunction getHeroName(code) {\n  return kaelin.hero_name[code];\n}\n\nwindow.onload = () => {\n\n  // Name\n  if (!localStorage.getItem(\"name\")) {\n    localStorage.setItem(\"name\", prompt(\"Your name:\"));\n  }\n  var name = localStorage.getItem(\"name\");\n\n  // State\n  var game;\n  function new_game(wait = false) {\n    game = {\n      index: 0,\n      ticks: [{turn: 0, text: \"Game begins.\", cast: null, board: kaelin.new_board}],\n      casts: [],\n      mouse: [0,0],\n      manual: false,\n      turn: 0,\n      begin_anim: null,\n      my_hero: null,\n      my_casts: [null, null, null, null]\n    };\n    if (!wait) {\n      render_game(game, canvas);\n    } else {\n      // TODO: clear timeout\n    }\n  };\n\n  const add_index = (add) => {\n    game.begin_anim = now();\n    if (add > 0 && game.index < game.ticks.length - 1) {\n      game.index += 1;\n      if (game.index === game.ticks.length - 1) {\n        game.manual = false;\n        post(\"Finish your casts. You have \" + CAST_TIME + \" seconds!\", \"log_green\");\n        game.casting = now();\n        castingTurn(game);\n      }\n    } else if (add < 0) { // Manually returning to previous state\n      game.index = Math.max(game.index + add, 0);\n      game.manual = true;\n    }\n  };\n\n  const castingTurn = (game) => {\n    setTimeout(() => {\n      var serialized = serialize_casts(game);\n      game.my_casts = [null, null, null, null];\n      if (serialized) { \n        ws.send(name + \": \" + serialized);\n        post(\"Sending \" + game.casts.length + \" casts.\", \"log_green\");\n      } else {\n        post(\"No casts for now.\");\n      }\n      nextTurn();\n      render_game(game, canvas);\n    }, CAST_TIME * 1000);\n  }\n\n\n  // ------\n  // Canvas\n  // ------\n  var canvas = Canvas(tile_size * 16 + 32, tile_size * 16 + 32);\n  document.getElementById(\"board_box\").appendChild(canvas);\n\n  // TODO: mais de uma pessoa pode dar o /next? \n  const nextTurn = () => {\n      setTimeout(() => {\n        ws.send(name + \": /next\");\n      }, 1000);\n  }\n\n  function getUnitOnFocus() {\n    var tick = game.ticks[Math.floor(game.index)];\n    var unit = kaelin.unit_to_json(kaelin.get_at(game.mouse)(tick.board)[1]);\n    return unit\n  }\n  \n  // ---------\n  // Keyboard\n  // ---------\n  document.body.onkeydown = e => {\n\n    // Manually controls turns prev/next    \n    if (e.key === \"ArrowLeft\" || e.key === \"ArrowRight\") {\n      add_index(e.key === \"ArrowLeft\" ? -1 : e.key === \"ArrowRight\" ? 1 : 0);\n    }\n\n    // Selects cast positions\n    if (/[xfds]/.test(e.key) && game.my_hero !== null) {\n      var slot = ({f: 3, d: 2, s: 1, x: 0})[e.key];\n      var tick = game.ticks[Math.floor(game.index)];\n      var unit = kaelin.unit_to_json(kaelin.get_at(game.mouse)(tick.board)[1]);\n      if (game.my_casts[slot] && dist(game.my_casts[slot], game.mouse) === 0) {\n        game.my_casts[slot] = null;\n      } else {\n        if (document.activeElement.id !== \"input\"){\n          game.my_casts[slot] = [game.mouse[0], game.mouse[1]];\n        }\n      }\n    }\n\n    // Removes selected\n    if (e.key === \"Escape\") {\n      game.my_casts = [null, null, null, null];\n    }\n\n    //render_game(game, canvas);\n  };\n\n  // Register mouse position\n  canvas.onmousemove = e => {\n    var [x,y] = [e.offsetX, e.offsetY];\n    var [i,j] = coord_to_pos([x,y]);\n    game.mouse = [i,j];\n  };\n\n  // TODO: adiconar heróis à sessão. \n\n  // Selects an unit\n  canvas.onclick = e => {\n    // Selects an unit before starting the game\n    if (game.index === 0){\n      var unit = getUnitOnFocus();\n      if (isHero(unit)) {\n        game.my_hero = getHeroCode(unit);\n        game.my_casts = [null, null, null, null];\n        post(\"Hero selected: \"+getHeroName(game.my_hero), \"log_green\");\n      }\n    }\n    //render_game(game, canvas);\n  };\n\n  // Sends my casts\n  const send_casts = () => {\n    ws.send(name + \": \" + serialize_casts(game));\n    game.my_casts = [null, null, null, null];\n  };\n\n  // --------\n  // Messages\n  // --------\n  let msgs = [];\n\n  // Posts something on chat\n  const post = (msg, className) => { \n    var msg_el = document.createElement(\"div\");\n    msg_el.className = \"message \" + className;\n    msg_el.innerText = msg;\n    chat.appendChild(msg_el);\n    chat_box.scrollTop = chat_box.scrollHeight;\n  };\n\n  const on_message = (line) => {\n    var player = line.slice(0, line.indexOf(\":\"));\n    var msg = line.slice(line.indexOf(\":\") + 2);\n\n    post(player + \": \" + msg);\n\n    // If it is a cast, parses it\n    if (msg[0] === \"@\") {\n      var new_casts = [];\n      var lines = msg.split(\"@\").filter(line => line.length > 0);\n      for (var i = 0; i < lines.length; ++i) {\n        try {\n          new_casts = new_casts.concat(parse_cast(lines[i]).filter(cast => cast[1] !== null));\n        } catch (e) {\n          post(\"[ERROR] On cast \" + i + \": \" + e, \"red_log\");\n        }\n      }\n      game.casts = game.casts.concat(new_casts);\n      post(\"Added \" + new_casts.length + \" casts to turn \" + game.turn + \"! Total: \" + game.casts.length + \".\", \"green_log\");\n    }\n\n    if (msg === \"/next\") {\n      // Get priority order\n      var casts = kaelin.sort_casts(game.casts);\n      for (var i = 0; i < casts.length; ++i) {\n        var show_args = args => typeof args === \"object\" ? args[0].toString(16) + args[1].toString(16) : String(args);\n        var hero =  getHeroName(casts[i][0] / 4);\n        var skill = kaelin.skill_name[casts[i][0]];\n        var args = \"(\" + show_args(casts[i][1]) + \")\";\n        var turn_message = hero + \" used \" + skill + args + \".\";\n        var tick = game.ticks[game.ticks.length - 1];\n        var new_board = kaelin.cast(casts[i])(tick.board);\n        game.ticks.push({\n          turn: game.turn,\n          text: turn_message,\n          cast: casts[i],\n          board: new_board\n        });\n      };\n      game.ticks.push({\n        turn: game.turn,\n        text: \"End turn.\",\n        cast: null,\n        board: kaelin.end_turn(game.ticks[game.ticks.length - 1].board)\n      });\n      post(\"Completed turn \" + game.turn + \" with \" + game.casts.length + \" casts!\", \"green_log\");\n      ++game.turn;\n      game.casts = [];\n    }\n    \n    // TODO: not working\n    console.log(\"Message: \"+msg);\n    if (msg === \"/finish\") {\n      console.log(\"Finish game\");\n      new_game(true);\n      game.ticks.push([0, \"Game finished by user.\", [skill, args], kaelin.new_board]);\n      chat.innerHTML = \"\";\n    }\n\n    // TODO: the game only begins after everybody is ready\n    if (msg === \"/ready\") {\n      console.log(\"READY!\");\n      // nextTurn();\n    }\n  }\n  // ----------\n  // Connection\n  // ----------\n  const ws = new WebSocket(\"ws://\" + location.host + \"/chat\");\n  ws.onopen = function open() {};\n  ws.onmessage = (data) => on_message(data.data);\n  // ----\n  // Chat\n  // ----\n  var chat = document.createElement(\"div\");\n  var chat_box = document.getElementById(\"chat_box\");\n  var input = document.getElementById(\"input\");\n  chat.style.width = \"100%\";\n  chat.style.height = \"100%\";\n  chat_box.appendChild(chat);\n  input.onkeypress = function(e) {\n    if (e.key === \"Enter\") {\n      ws.send(name + \": \" + input.value);\n      setTimeout(() => {\n        input.value = \"\";\n      }, 0);\n    }\n  };\n\n  // Tips\n  var tips_box = document.getElementById(\"tips_box\");\n  var tips = [\n    \"Hero    | Skill S           | Skill D             | Skill F\",\n    \"------- | ----------------- | ------------------- | -----------------\",\n    \"TOPHORO | Earth_Root*       | Earth_Wall*         | Earth_Rise       \",\n    \"GONK    | Empathy*          | Revenge*            | Ground_Slam      \",\n    \"STANCI  | Restore*          | Escort*             | Detain*          \",\n    \"ERKOS   | Flame_Ball        | Flame_Wave          | Flame_Nova       \",\n    \"CRONI   | Shadow_Bond*      | Shadow_Trap*        | Shadow_Flux      \",\n    \"SNARCH  | Ballista*         | Quick_Bolt_0*       | Quick_Bolt_1*    \",\n    \"SIRPIX  | Stealth_Move*     | Stealth_Strike*     | Lockpick         \",\n    \"KENLUA  | Haste*            | Dodge*              | Slash            \",\n    \"FLINA   | Javelin*          | Fly                 | Gust             \",\n    \"ZAGATUR | Wrap*             | Needle              | Summon           \",\n    \"AGDRIS  | Memento*          | Silence*            | Protect*         \",\n    \"MEWRU   | Teleport*         | Psychock            | Imprison         \",\n\n  ].join(\"\\n\");\n  tips_box.innerText = tips;\n\n  // Animation\n  setInterval(() => {\n    if (!game.manual && game.index < game.ticks.length - 1) {\n      add_index(1);\n      //game.index += 1;\n      render_game(game, canvas);\n    }\n  }, TICK_TIME * 1000);\n\n  // Rendering\n  setInterval(() => {\n    render_game(game, canvas);\n  }, 100);\n\n  new_game();\n};\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/kaelin.js":
/*!***********************!*\
  !*** ./src/kaelin.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fm = __webpack_require__(/*! formality-core */ \"./node_modules/formality-core/exports.js\");\n\n//try {\n  var code = __webpack_require__(/*! ./../formality/stdlib/_export_to_webpack_.js */ \"./formality/stdlib/_export_to_webpack_.js\");\n//} catch (e) {\n  //var code = require(\"./../../formality-core/examples/_export_to_node_.js\");\n//}\nconst {infs, defs} = fm.core.parse(code);\nconsole.log(\"defs: \",defs[\"Stack.push\"]);\nconst compile      = name => fm.to_js.compile(defs[name], defs);\nconst Cons         = compile(\"Cons\");\nconst Nil          = compile(\"Nil\");\nconst\n  [new_board,\n  [cast,\n  [print_board,\n  [unit_to_scott,\n  [get_skill_priority,\n  [get_skill_area,\n  [get_at,\n  [end_turn,\n  [TOPHORO,\n  [GONK,\n  [STANCI,\n  [HERO_03,\n  [ERKOS,\n  [CRONI,\n  [SNARCH,\n  [HERO_07,\n  [SIRPIX,\n  [KENLUA,\n  [FLINA,\n  [HERO_11,\n  [ZAGATUR,\n  [AGDRIS,\n  [MEWEM,\n  [HERO_15,\n  ]]]]]]]]]]]]]]]]]]]]]]]]\n  = compile(\"kaelin\");\n\nconst sort_casts = casts => {\n  var map = {};\n  for (var i = 0; i < casts.length; ++i) {\n    map[get_skill_priority(casts[i][0])] = casts[i];\n  }\n  var new_casts = [];\n  for (var i = 0; i < 64; ++i) {\n    if (map[i]) {\n      new_casts.push(map[i]);\n    }\n  }\n  return new_casts;\n};\n\nconst skill_name = {\n  0: \"TOPHORO_WALK\",\n  1: \"EARTH_ROOT\",\n  2: \"EARTH_WALL\",\n  3: \"EARTH_RISE\",\n  4: \"GONK_WALK\",\n  5: \"EMPATHY\",\n  6: \"REVENGE\",\n  7: \"GROUND_SLAM\",\n  8: \"STANCI_WALK\",\n  9: \"RESTORE\",\n  10: \"ESCORT\",\n  11: \"DETAIN\",\n  16: \"ERKOS_WALK\",\n  17: \"FLAME_BALL\",\n  18: \"FLAME_WAVE\",\n  19: \"FLAME_NOVA\",\n  20: \"CRONI_WALK\",\n  21: \"SHADOW_BOND\",\n  22: \"SHADOW_TRAP\",\n  23: \"SHADOW_FLUX\",\n  24: \"SNARCH_WALK\",\n  25: \"BALLISTA\",\n  26: \"QUICK_BOLT_0\",\n  27: \"QUICK_BOLT_1\",\n  32: \"SIRPIX_WALK\",\n  33: \"STEALTH_MOVE\",\n  34: \"STEALTH_STRIKE\",\n  35: \"LOCKPICK\",\n  36: \"KENLUA_WALK\",\n  37: \"HASTE\",\n  38: \"DODGE\",\n  39: \"SLASH\",\n  40: \"FLINA_WALK\",\n  41: \"JAVELIN\",\n  42: \"FLY\",\n  43: \"GUST\",\n  48: \"ZAGATUR_WALK\",\n  49: \"NEEDLE\",\n  50: \"WRAP\",\n  51: \"SUMMON\",\n  52: \"AGDRIS_WALK\",\n  53: \"PROTECT\",\n  54: \"SILENCE\",\n  55: \"MEMENTO\",\n  56: \"MEWEN_WALK\",\n  57: \"TELEPORT\",\n  58: \"PSYCHOCK\",\n  59: \"IMPRISON\",\n};\n\nconst hero_name = {\n  0: \"Tophoro\",\n  1: \"Gonk\",\n  2: \"Stanci\",\n  3: \"?????\",\n  4: \"Erkos\",\n  5: \"Croni\",\n  6: \"Snarch\",\n  7: \"?????\",\n  8: \"Sirpix\",\n  9: \"Kenlua\",\n  10: \"Flina\",\n  11: \"?????\",\n  12: \"Zagatur\",\n  13: \"Agdris\",\n  14: \"Mewem\",\n  15: \"?????\",\n};\n\n// Converts board to JSON\nconst unit_to_json = unit => {\n  let case_void = [\"Void\"];\n  let case_item = type => [\"Item\", {type}];\n  let case_goal = side => [\"Goal\", {side}];\n  let case_hero = side => hero => life => defs => eff1 => lock => mute => spec => [\"Hero\", {side, hero, life, defs, eff1, lock, mute, spec}];\n  return unit_to_scott(unit)(case_void)(case_item)(case_goal)(case_hero);\n};\n\n// Converts board to JSON\nconst board_to_json = (val, i = 0) => {\n  if (i < 8) {\n    return board_to_json(val[0], i + 1).concat(board_to_json(val[1], i + 1));\n  } else {\n    return [unit_to_json(val)];\n  }\n};\n\nmodule.exports = {\n  sort_casts,\n  Cons,\n  Nil,\n  new_board,\n  cast,\n  print_board,\n  unit_to_scott,\n  get_skill_priority,\n  get_skill_area,\n  get_at,\n  end_turn,\n  skill_name,\n  hero_name,\n  unit_to_json,\n  board_to_json,\n  TOPHORO,\n  GONK,\n  STANCI,\n  HERO_03,\n  ERKOS,\n  CRONI,\n  SNARCH,\n  HERO_07,\n  SIRPIX,\n  KENLUA,\n  FLINA,\n  HERO_11,\n  ZAGATUR,\n  AGDRIS,\n  MEWEM,\n  HERO_15,\n};\n\n\n//# sourceURL=webpack:///./src/kaelin.js?");

/***/ }),

/***/ "./src/keyboard.js":
/*!*************************!*\
  !*** ./src/keyboard.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Keyboard\nconst Keyboard = (callbacks) => {\n  callbacks.down = callbacks.down || function(){};\n  callbacks.up = callbacks.up || function(){};\n  var key = {};\n  document.addEventListener(\"keydown\", e => { key[e.key] = 1; callbacks.down(e.key); });\n  document.addEventListener(\"keyup\", e => { key[e.key] = 0; callbacks.up(e.key); });\n  return key;\n};\n\nmodule.exports = Keyboard;\n\n\n//# sourceURL=webpack:///./src/keyboard.js?");

/***/ }),

/***/ "./src/parse_cast.js":
/*!***************************!*\
  !*** ./src/parse_cast.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const kaelin = __webpack_require__(/*! ./kaelin.js */ \"./src/kaelin.js\");\n\nconst parse_cast = (code) => {\n  const parse_hero = (str) => {\n    switch (str.toLowerCase()) {\n      case \"to\": var hero = kaelin.TOPHORO ; break;\n      case \"go\": var hero = kaelin.GONK    ; break;\n      case \"st\": var hero = kaelin.STANCI  ; break;\n      case \"h3\": var hero = kaelin.HERO_3  ; break;\n      case \"er\": var hero = kaelin.ERKOS   ; break;\n      case \"cr\": var hero = kaelin.CRONI   ; break;\n      case \"sn\": var hero = kaelin.SNARCH  ; break;\n      case \"h7\": var hero = kaelin.HERO_7  ; break;\n      case \"si\": var hero = kaelin.SIRPIX  ; break;\n      case \"ke\": var hero = kaelin.KENLUA  ; break;\n      case \"fl\": var hero = kaelin.FLINA   ; break;\n      case \"hb\": var hero = kaelin.HERO_B  ; break;\n      case \"za\": var hero = kaelin.ZAGATUR ; break;\n      case \"ag\": var hero = kaelin.AGDRIS  ; break;\n      case \"me\": var hero = kaelin.MEWEM   ; break;\n      case \"hf\": var hero = kaelin.HERO_F  ; break;\n      default: throw \"Invalid hero `\" + code.slice(0,2) + \"\\`.\";\n    }\n    return hero;\n  };\n\n  const parse_pos = (pos) => {\n    if (pos.length !== 2 || !/[0-9a-fA-F]/.test(pos[0]) || !/[0-9a-fA-F]/.test(pos[1])) {\n      throw \"Invalid position `\" + pos + \"`.\";\n    }\n    return [parseInt(pos[0], 16), parseInt(pos[1], 16)];\n  };\n\n  var words = code.split(\" \").slice(0, 5);\n  while (words.length < 5) {\n    words.push(\".\");\n  }\n\n  var hero = parse_hero(words[0]);\n  try { var walk = words[1] === \".\" ? null : parse_pos(words[1]); } catch (e) { throw e + \" (When parsing walk.)\"; }\n  try { var skl0 = words[2] === \".\" ? null : parse_pos(words[2]); } catch (e) { throw e + \" (When parsing skill 0.)\" };\n  try { var skl1 = words[3] === \".\" ? null : parse_pos(words[3]); } catch (e) { throw e + \" (When parsing skill 1.)\" };\n  try { var skl2 = words[4] === \".\" ? null : parse_pos(words[4]); } catch (e) { throw e + \" (When parsing skill 2.)\" };\n\n  return [[hero * 4 + 0, walk], [hero * 4 + 1, skl0], [hero * 4 + 2, skl1], [hero * 4 + 3, skl2]];\n};\n\nmodule.exports = parse_cast;\n\n\n//# sourceURL=webpack:///./src/parse_cast.js?");

/***/ })

/******/ });